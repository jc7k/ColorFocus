<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;">
  <title>ColorFocus - Stroop Puzzle</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #f8fafc;
      padding: 1.5rem;
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      font-size: 1.75rem;
      font-weight: bold;
      margin-bottom: 0.25rem;
    }
    .subtitle {
      color: #64748b;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }
    .donation-link {
      display: inline-block;
      color: #92400e;
      font-size: 0.9rem;
      font-weight: 500;
      text-decoration: none;
      margin-bottom: 1rem;
      padding: 0.4rem 0.8rem;
      background: #fef3c7;
      border-radius: 6px;
      border: 1px solid #fcd34d;
      transition: all 0.2s ease;
    }
    .donation-link:hover {
      background: #fde68a;
      border-color: #f59e0b;
      color: #78350f;
    }
    .donation-link:focus {
      outline: 2px solid #2563eb;
      outline-offset: 2px;
    }
    .controls {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    label {
      font-size: 0.8rem;
      color: #475569;
    }
    input[type="number"], select {
      width: 70px;
      padding: 0.4rem;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      font-size: 0.8rem;
    }
    select {
      width: auto;
    }
    button {
      padding: 0.4rem 0.75rem;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background: #1d4ed8;
    }
    button:disabled {
      background: #94a3b8;
      cursor: not-allowed;
    }
    button.secondary {
      background: #64748b;
    }
    button.secondary:hover {
      background: #475569;
    }
    button.success {
      background: #16a34a;
    }
    button.success:hover {
      background: #15803d;
    }
    .puzzle-container {
      background: white;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 1rem;
    }
    .puzzle-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
      max-width: 800px;
      margin: 0 auto;
    }
    .puzzle-cell {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.5rem;
      font-weight: bold;
      border-radius: 4px;
      background: #f8fafc;
      transition: transform 0.1s;
    }
    .puzzle-cell:hover {
      transform: scale(1.08);
      z-index: 1;
    }
    .metadata {
      display: flex;
      gap: 1.5rem;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid #e2e8f0;
      font-size: 0.8rem;
      color: #64748b;
      flex-wrap: wrap;
    }
    .metadata-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .metadata-value {
      font-weight: 600;
      color: #334155;
    }
    .task-instructions {
      background: #fef3c7;
      border-radius: 8px;
      padding: 0.75rem;
      margin-bottom: 1rem;
      color: #92400e;
      font-size: 0.85rem;
    }
    .task-instructions strong {
      display: block;
      margin-bottom: 0.15rem;
    }

    /* Answer Submission Section */
    .answer-section {
      background: white;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 1rem;
    }
    .answer-section h2 {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .answer-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    @media (max-width: 600px) {
      .answer-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    .answer-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem;
      border-radius: 8px;
      background: #f8fafc;
      transition: background 0.2s, box-shadow 0.2s;
    }
    .answer-item.correct {
      background: #dcfce7;
      box-shadow: 0 0 0 2px #16a34a;
    }
    .answer-item.incorrect {
      background: #fee2e2;
      box-shadow: 0 0 0 2px #dc2626;
    }
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      flex-shrink: 0;
    }
    .answer-label {
      font-size: 0.85rem;
      font-weight: 500;
      flex: 1;
      min-width: 0;
    }
    .answer-input {
      width: 50px;
      padding: 0.35rem;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      font-size: 0.85rem;
      text-align: center;
      font-weight: 600;
    }
    .answer-input:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    .answer-input.correct {
      border-color: #16a34a;
      background: #f0fdf4;
    }
    .answer-input.incorrect {
      border-color: #dc2626;
      background: #fef2f2;
    }
    .correct-value {
      font-size: 0.75rem;
      color: #16a34a;
      font-weight: 600;
      min-width: 30px;
      text-align: center;
    }
    .answer-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    /* Results Section */
    .results-section {
      background: white;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin-bottom: 1rem;
      display: none;
    }
    .results-section.visible {
      display: block;
    }
    .results-section h2 {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
    }
    .results-summary {
      display: flex;
      gap: 2rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    .result-stat {
      text-align: center;
    }
    .result-stat .value {
      font-size: 2rem;
      font-weight: bold;
      line-height: 1;
    }
    .result-stat .label {
      font-size: 0.75rem;
      color: #64748b;
      margin-top: 0.25rem;
    }
    .result-stat.perfect .value {
      color: #16a34a;
    }
    .result-stat.good .value {
      color: #2563eb;
    }
    .result-stat.needs-work .value {
      color: #dc2626;
    }
    .result-message {
      padding: 0.75rem;
      border-radius: 8px;
      font-size: 0.85rem;
    }
    .result-message.perfect {
      background: #dcfce7;
      color: #166534;
    }
    .result-message.good {
      background: #dbeafe;
      color: #1e40af;
    }
    .result-message.needs-work {
      background: #fee2e2;
      color: #991b1b;
    }

    /* Answer Key Section (Hidden by Default) */
    .answer-key-section {
      background: white;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .answer-key-section h2 {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .answer-key-content {
      display: none;
    }
    .answer-key-content.revealed {
      display: block;
    }
    .answer-key-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
    }
    .answer-key-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.8rem;
      padding: 0.4rem;
      background: #f8fafc;
      border-radius: 6px;
    }
    .answer-key-label {
      flex: 1;
    }
    .answer-key-count {
      font-weight: 600;
      color: #334155;
    }
    .reveal-warning {
      background: #fef3c7;
      padding: 0.5rem;
      border-radius: 6px;
      font-size: 0.8rem;
      color: #92400e;
      margin-bottom: 0.75rem;
    }

    /* Donation QR Code Section */
    .donation-section {
      background: white;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      text-align: center;
      margin-top: 1rem;
    }
    .donation-qr {
      width: 140px;
      height: auto;
      display: block;
      margin: 0 auto 0.5rem auto;
    }
    .donation-label {
      color: #64748b;
      font-size: 0.8rem;
      margin: 0;
    }

    /* Custom controls visibility (shown only in Custom difficulty) */
    .custom-control {
      display: none;
    }
    .custom-control.visible {
      display: flex;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 480px) {
      body {
        padding: 0.75rem;
        max-width: 100%;
      }
      h1 {
        font-size: 1.35rem;
      }
      .subtitle {
        font-size: 0.8rem;
      }
      .donation-link {
        font-size: 0.8rem;
        min-height: 44px;
        display: flex;
        align-items: center;
      }
      .task-instructions {
        font-size: 0.75rem;
        padding: 0.6rem;
      }
      .controls {
        gap: 0.5rem;
      }
      .control-group {
        gap: 0.25rem;
      }
      label {
        font-size: 0.7rem;
      }
      input[type="number"], select {
        width: 55px;
        padding: 0.3rem;
        font-size: 0.75rem;
      }
      button {
        padding: 0.35rem 0.5rem;
        font-size: 0.75rem;
      }
      .puzzle-container {
        padding: 0.5rem;
        overflow-x: hidden;
      }
      .puzzle-grid {
        gap: 1px;
        width: 100%;
      }
      .puzzle-cell {
        border-radius: 2px;
        padding: 0.1rem;
        overflow: hidden;
        text-overflow: clip;
      }
      .puzzle-cell:hover {
        transform: none;
      }
      .metadata {
        gap: 0.75rem;
        font-size: 0.7rem;
        justify-content: center;
      }
      .answer-section {
        padding: 0.75rem;
      }
      .answer-section h2 {
        font-size: 0.85rem;
      }
      .answer-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
      }
      .answer-item {
        padding: 0.4rem;
        gap: 0.3rem;
      }
      .color-swatch {
        width: 18px;
        height: 18px;
      }
      .answer-label {
        font-size: 0.75rem;
      }
      .answer-input {
        width: 40px;
        padding: 0.25rem;
        font-size: 0.8rem;
      }
      .correct-value {
        font-size: 0.65rem;
        min-width: 20px;
      }
      .results-section {
        padding: 0.75rem;
      }
      .results-summary {
        gap: 1rem;
        justify-content: center;
      }
      .result-stat .value {
        font-size: 1.5rem;
      }
      .result-stat .label {
        font-size: 0.65rem;
      }
      .result-message {
        font-size: 0.75rem;
        padding: 0.6rem;
      }
      .answer-key-section {
        padding: 0.75rem;
      }
      .answer-key-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.4rem;
      }
      .answer-key-item {
        font-size: 0.7rem;
        padding: 0.3rem;
      }
      .reveal-warning {
        font-size: 0.7rem;
        padding: 0.4rem;
      }
      .donation-section {
        padding: 0.75rem;
      }
      .donation-qr {
        width: 120px;
      }
      .donation-label {
        font-size: 0.75rem;
      }
    }

    /* Extra small devices (iPhone SE, etc.) */
    @media (max-width: 375px) {
      body {
        padding: 0.5rem;
      }
      h1 {
        font-size: 1.2rem;
      }
      .puzzle-cell {
        font-size: 1.25rem;
      }
      .controls {
        justify-content: center;
      }
      input[type="number"], select {
        width: 50px;
      }
      .donation-qr {
        width: 100px;
      }
      .donation-label {
        font-size: 0.7rem;
      }
    }
  </style>
</head>
<body>
  <h1 id="pageTitle">ColorFocus Stroop Puzzle</h1>
  <p class="subtitle" id="subtitle">Count the INK colors, not the word meanings!</p>
  <a href="https://buymeacoffee.com/xwje4mbv3l"
     target="_blank"
     rel="noopener noreferrer"
     class="donation-link"
     id="donationLink"
     data-i18n="support_link_text">Support this project</a>

  <div class="task-instructions" id="taskInstructions">
    <strong>Task:</strong> Count how many cells are printed in each INK color. The Chinese character shows a color name, but you must count the actual ink color used to display it.
  </div>

  <div class="controls">
    <div class="control-group">
      <label for="difficulty" id="difficultyLabel">Difficulty:</label>
      <select id="difficulty" aria-label="Select difficulty tier">
        <option value="accessible">Accessible</option>
        <option value="standard" selected>Standard</option>
        <option value="advanced">Advanced</option>
        <option value="custom">Custom</option>
      </select>
    </div>
    <div class="control-group">
      <label for="language" id="languageLabel">Language:</label>
      <select id="language" aria-label="Select display language">
        <option value="chinese" selected>Chinese</option>
        <option value="english">English</option>
        <option value="spanish">Spanish</option>
        <option value="vietnamese">Vietnamese</option>
      </select>
    </div>
    <div class="control-group">
      <label for="spacing" id="spacingLabel">Spacing:</label>
      <select id="spacing" aria-label="Select grid spacing">
        <option value="compact">Compact</option>
        <option value="normal" selected>Normal</option>
        <option value="relaxed">Relaxed</option>
        <option value="spacious">Spacious</option>
      </select>
    </div>
    <div class="control-group custom-control" id="gridSizeGroup">
      <label for="gridSize" id="gridLabel">Grid:</label>
      <select id="gridSize" aria-label="Select grid size">
        <option value="1">1x1</option>
        <option value="2">2x2</option>
        <option value="3">3x3</option>
        <option value="4" selected>4x4</option>
        <option value="5">5x5</option>
        <option value="6">6x6</option>
        <option value="7">7x7</option>
        <option value="8">8x8</option>
      </select>
    </div>
    <div class="control-group custom-control" id="colorCountGroup">
      <label for="colorCount" id="colorsLabel">Colors:</label>
      <select id="colorCount">
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4" selected>4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
      </select>
    </div>
    <div class="control-group custom-control" id="congruenceGroup">
      <label for="congruence" id="matchLabel">Match %:</label>
      <input type="number" id="congruence" value="12.5" min="0" max="100" step="0.1">
    </div>
    <div class="control-group">
      <label for="seed" id="seedLabel">Seed:</label>
      <input type="number" id="seed" value="42" min="0">
    </div>
    <button id="generateBtn">Generate</button>
    <button id="randomBtn" class="secondary">Random</button>
  </div>

  <div class="puzzle-container">
    <div class="puzzle-grid" id="puzzleGrid"></div>
    <div class="metadata" id="metadata"></div>
  </div>

  <!-- Answer Submission Section -->
  <div class="answer-section">
    <h2 id="enterAnswersHeader">Enter Your Answers</h2>
    <div class="answer-grid" id="answerGrid"></div>
    <div class="answer-buttons">
      <button class="success" id="checkBtn">Check Answers</button>
      <button class="secondary" id="clearBtn">Clear</button>
    </div>
  </div>

  <!-- Results Section -->
  <div class="results-section" id="resultsSection">
    <h2 id="resultsHeader">Results</h2>
    <div class="results-summary" id="resultsSummary"></div>
    <div class="result-message" id="resultMessage"></div>
  </div>

  <!-- Answer Key Section (Hidden by Default) -->
  <div class="answer-key-section">
    <h2>
      <span id="answerKeyHeader">Answer Key</span>
      <button class="secondary" id="revealBtn">Reveal</button>
    </h2>
    <div class="reveal-warning" id="revealWarning">
      Revealing the answer key will end your current attempt. Check your answers first!
    </div>
    <div class="answer-key-content" id="answerKeyContent">
      <div class="answer-key-grid" id="answerKeyGrid"></div>
    </div>
  </div>

  <!-- Donation QR Code Section -->
  <div class="donation-section">
    <a href="https://buymeacoffee.com/xwje4mbv3l" target="_blank" rel="noopener noreferrer">
      <img src="/frontend/bmc_qr.png" alt="QR code to support ColorFocus via Buy Me A Coffee" class="donation-qr">
    </a>
    <p class="donation-label" id="donationLabel" data-i18n="qr_code_label">Scan to support ColorFocus</p>
  </div>

  <script type="module">
    // Load JSON files via fetch for better iOS Safari compatibility
    // (ES module import attributes can fail to fully parse large JSON on some iOS versions)
    async function loadJSON(path) {
      const response = await fetch(path);
      if (!response.ok) throw new Error(`Failed to load ${path}`);
      return response.json();
    }

    const [colorsJson, colorLabelsJson, uiTextJson] = await Promise.all([
      loadJSON('/shared/colors.json'),
      loadJSON('/shared/color_labels.json'),
      loadJSON('/shared/ui_text.json')
    ]);

    // All color tokens in order
    const ALL_COLOR_TOKENS = ['BLUE', 'ORANGE', 'PURPLE', 'BLACK', 'CYAN', 'AMBER', 'MAGENTA', 'GRAY'];

    // Color subsets by count (ordered by distinctiveness)
    const COLOR_SUBSETS = {
      2: ['BLUE', 'ORANGE'],
      3: ['BLUE', 'ORANGE', 'PURPLE'],
      4: ['BLUE', 'ORANGE', 'PURPLE', 'BLACK'],
      5: ['BLUE', 'ORANGE', 'PURPLE', 'BLACK', 'CYAN'],
      6: ['BLUE', 'ORANGE', 'PURPLE', 'BLACK', 'CYAN', 'AMBER'],
      7: ['BLUE', 'ORANGE', 'PURPLE', 'BLACK', 'CYAN', 'AMBER', 'MAGENTA'],
      8: ALL_COLOR_TOKENS,
    };

    // Valid language values for input validation
    const VALID_LANGUAGES = ['chinese', 'english', 'spanish', 'vietnamese'];

    // Valid grid sizes (1-8)
    const VALID_GRID_SIZES = [1, 2, 3, 4, 5, 6, 7, 8];

    // Valid difficulty tiers
    const VALID_DIFFICULTIES = ['accessible', 'standard', 'advanced', 'custom'];

    // Valid spacing options
    const VALID_SPACINGS = ['compact', 'normal', 'relaxed', 'spacious'];

    // Difficulty tier presets: { gridSize, colorCount, congruencePercent }
    const DIFFICULTY_PRESETS = {
      accessible: { gridSize: 3, colorCount: 2, congruencePercent: 50 },
      standard: { gridSize: 4, colorCount: 4, congruencePercent: 12.5 },
      advanced: { gridSize: 8, colorCount: 8, congruencePercent: 0 }
    };

    // Spacing presets: gap in pixels
    const SPACING_VALUES = {
      compact: 1,
      normal: 2,
      relaxed: 6,
      spacious: 12
    };

    // Sanitize text content to prevent XSS (escapes HTML entities)
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Validate and sanitize numeric input
    function sanitizeNumber(value, min, max, defaultValue) {
      const num = parseFloat(value);
      if (isNaN(num)) return defaultValue;
      return Math.max(min, Math.min(max, num));
    }

    // Validate language selection
    function validateLanguage(lang) {
      return VALID_LANGUAGES.includes(lang) ? lang : 'chinese';
    }

    // Validate grid size selection
    function validateGridSize(size) {
      const num = parseInt(size, 10);
      return VALID_GRID_SIZES.includes(num) ? num : 4;
    }

    // Validate difficulty selection
    function validateDifficulty(difficulty) {
      return VALID_DIFFICULTIES.includes(difficulty) ? difficulty : 'standard';
    }

    // Validate spacing selection
    function validateSpacing(spacing) {
      return VALID_SPACINGS.includes(spacing) ? spacing : 'normal';
    }

    // Get UI text for the current language
    function getUIText(key) {
      if (uiTextJson[key] && uiTextJson[key][currentLanguage]) {
        return uiTextJson[key][currentLanguage];
      }
      // Fallback to English if key or language not found
      if (uiTextJson[key] && uiTextJson[key]['english']) {
        return uiTextJson[key]['english'];
      }
      return key; // Return key itself as last resort
    }

    // Get language descriptor for task instructions
    function getLanguageDescriptor() {
      const descriptorKey = `language_descriptor_${currentLanguage}`;
      return getUIText(descriptorKey);
    }

    // State
    let currentPuzzle = null;
    let correctAnswers = {};
    let activeColors = [];
    let hasChecked = false;
    let answerKeyRevealed = false;
    // Validate language from localStorage
    let currentLanguage = validateLanguage(localStorage.getItem('colorFocusLanguage') || 'chinese');
    // Validate grid size from localStorage (default: 4)
    let currentGridSize = validateGridSize(localStorage.getItem('colorFocusGridSize') || 4);
    // Validate difficulty from localStorage (default: standard)
    let currentDifficulty = validateDifficulty(localStorage.getItem('colorFocusDifficulty') || 'standard');
    // Validate spacing from localStorage (default: normal)
    let currentSpacing = validateSpacing(localStorage.getItem('colorFocusSpacing') || 'normal');

    // Initialize language selector with saved preference
    document.getElementById('language').value = currentLanguage;

    // Initialize grid size selector with saved preference
    document.getElementById('gridSize').value = currentGridSize;

    // Initialize difficulty selector with saved preference
    document.getElementById('difficulty').value = currentDifficulty;

    // Initialize spacing selector with saved preference
    document.getElementById('spacing').value = currentSpacing;

    // Show/hide custom controls based on difficulty
    function updateCustomControlsVisibility() {
      const isCustom = currentDifficulty === 'custom';
      document.querySelectorAll('.custom-control').forEach(el => {
        el.classList.toggle('visible', isCustom);
      });
    }

    // Apply difficulty preset to controls
    function applyDifficultyPreset(difficulty) {
      if (difficulty === 'custom') return; // Don't modify values in custom mode

      const preset = DIFFICULTY_PRESETS[difficulty];
      if (!preset) return;

      // Update state
      currentGridSize = preset.gridSize;

      // Update UI - grid size and congruence first
      document.getElementById('gridSize').value = preset.gridSize;
      document.getElementById('congruence').value = preset.congruencePercent;

      // Save grid size preference
      localStorage.setItem('colorFocusGridSize', currentGridSize);

      // Update color dropdown options for new grid size, then set color count
      updateColorDropdownOptions();
      document.getElementById('colorCount').value = preset.colorCount;
    }

    // Update grid CSS for current grid size and spacing
    function updateGridCSS() {
      const grid = document.getElementById('puzzleGrid');
      grid.style.gridTemplateColumns = `repeat(${currentGridSize}, 1fr)`;
      grid.style.gap = `${SPACING_VALUES[currentSpacing]}px`;
    }

    // Update Colors dropdown based on grid size (auto-limiting)
    function updateColorDropdownOptions() {
      const colorSelect = document.getElementById('colorCount');
      const maxColors = Math.min(8, currentGridSize);
      const currentColorValue = parseInt(colorSelect.value, 10);

      // Clear existing options
      colorSelect.innerHTML = '';

      // Add options from 1 to maxColors (minimum 1 color for 1x1 grid)
      const minColors = Math.min(2, maxColors);
      for (let i = minColors; i <= maxColors; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = i;
        if (i === Math.min(currentColorValue, maxColors)) {
          option.selected = true;
        }
        colorSelect.appendChild(option);
      }

      // If current selection exceeds new max, clamp it
      if (currentColorValue > maxColors) {
        colorSelect.value = maxColors;
      }
    }

    // Update all UI text elements with translations
    function updateAllUIText() {
      // Update page title (h1 and document.title)
      const pageTitle = getUIText('page_title');
      document.getElementById('pageTitle').textContent = pageTitle;
      document.title = pageTitle;

      // Update subtitle
      document.getElementById('subtitle').textContent = getUIText('subtitle');

      // Update donation link text
      document.getElementById('donationLink').textContent = getUIText('support_link_text');

      // Update donation QR code label
      document.getElementById('donationLabel').textContent = getUIText('qr_code_label');

      // Update control labels
      document.getElementById('difficultyLabel').textContent = getUIText('difficulty_label');
      document.getElementById('languageLabel').textContent = getUIText('language_label');
      document.getElementById('spacingLabel').textContent = getUIText('spacing_label');
      document.getElementById('gridLabel').textContent = getUIText('grid_label');
      document.getElementById('colorsLabel').textContent = getUIText('colors_label');
      document.getElementById('seedLabel').textContent = getUIText('seed_label');
      document.getElementById('matchLabel').textContent = getUIText('match_label');

      // Update difficulty dropdown options
      const difficultySelect = document.getElementById('difficulty');
      difficultySelect.options[0].textContent = getUIText('difficulty_accessible');
      difficultySelect.options[1].textContent = getUIText('difficulty_standard');
      difficultySelect.options[2].textContent = getUIText('difficulty_advanced');
      difficultySelect.options[3].textContent = getUIText('difficulty_custom');

      // Update spacing dropdown options
      const spacingSelect = document.getElementById('spacing');
      spacingSelect.options[0].textContent = getUIText('spacing_compact');
      spacingSelect.options[1].textContent = getUIText('spacing_normal');
      spacingSelect.options[2].textContent = getUIText('spacing_relaxed');
      spacingSelect.options[3].textContent = getUIText('spacing_spacious');

      // Update button text
      document.getElementById('generateBtn').textContent = getUIText('generate_btn');
      document.getElementById('randomBtn').textContent = getUIText('random_btn');
      document.getElementById('checkBtn').textContent = getUIText('check_btn');
      document.getElementById('clearBtn').textContent = getUIText('clear_btn');

      // Update reveal button based on current state
      const revealBtn = document.getElementById('revealBtn');
      revealBtn.textContent = answerKeyRevealed ? getUIText('hide_btn') : getUIText('reveal_btn');

      // Update section headers
      document.getElementById('enterAnswersHeader').textContent = getUIText('enter_answers_header');
      document.getElementById('resultsHeader').textContent = getUIText('results_header');
      document.getElementById('answerKeyHeader').textContent = getUIText('answer_key_header');

      // Update reveal warning
      document.getElementById('revealWarning').textContent = getUIText('reveal_warning');

      // Update task instructions
      updateTaskInstructions();
    }

    // Add difficulty change event listener
    document.getElementById('difficulty').addEventListener('change', (e) => {
      currentDifficulty = validateDifficulty(e.target.value);
      localStorage.setItem('colorFocusDifficulty', currentDifficulty);
      updateCustomControlsVisibility();
      applyDifficultyPreset(currentDifficulty);
      generatePuzzle();
    });

    // Add language change event listener
    document.getElementById('language').addEventListener('change', (e) => {
      currentLanguage = e.target.value;
      localStorage.setItem('colorFocusLanguage', currentLanguage);
      updateAllUIText();
      renderPuzzleDisplay();
      renderAnswerInputs();
      renderAnswerKey();
      updateMetadata();
      // Recalculate font size for new language (different word lengths)
      applyPuzzleFontSize();
    });

    // Add spacing change event listener
    document.getElementById('spacing').addEventListener('change', (e) => {
      currentSpacing = validateSpacing(e.target.value);
      localStorage.setItem('colorFocusSpacing', currentSpacing);
      updateGridCSS();
      // Recalculate font size since spacing affects cell width
      applyPuzzleFontSize();
    });

    // Add grid size change event listener (only active in Custom mode)
    document.getElementById('gridSize').addEventListener('change', (e) => {
      currentGridSize = validateGridSize(e.target.value);
      localStorage.setItem('colorFocusGridSize', currentGridSize);
      updateGridCSS();
      updateColorDropdownOptions();
      generatePuzzle();
    });

    // Seeded random number generator (mulberry32)
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    // Shuffle array with seeded random
    function shuffle(array, random) {
      const result = [...array];
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    }

    // Update task instructions text based on language
    function updateTaskInstructions() {
      const languageDescriptor = getLanguageDescriptor();
      const taskInstruction = getUIText('task_instruction').replace('{language_descriptor}', languageDescriptor);

      const container = document.getElementById('taskInstructions');
      container.textContent = ''; // Clear safely

      const strong = document.createElement('strong');
      strong.textContent = getUIText('task_label');
      container.appendChild(strong);

      container.appendChild(document.createTextNode(' ' + taskInstruction));
    }

    // Calculate optimal font size based on viewport, language, and grid size
    // Uses dynamic calculation: baseFontSize = (cellWidth * 0.8) / languageWidthMultiplier
    // The 0.8 factor achieves 80% text width with 10% margins on each side
    function calculatePuzzleFontSize() {
      const viewportWidth = window.innerWidth;
      const isMobile = viewportWidth <= 480;

      // Get actual grid width from DOM
      const grid = document.getElementById('puzzleGrid');
      const gridWidth = grid ? grid.offsetWidth : (isMobile ? viewportWidth - 40 : 800);

      // Use currentGridSize for column count
      const columns = currentGridSize;

      // Get current gap value from SPACING_VALUES based on current spacing setting
      // Mobile media query forces 1px gap, otherwise use the spacing setting
      const gapValue = isMobile ? 1 : SPACING_VALUES[currentSpacing];

      // Calculate total gap width: (columns - 1) gaps between columns
      const totalGapWidth = (columns - 1) * gapValue;

      // Mobile has extra cell padding (0.1rem = ~1.6px per cell)
      const cellPadding = isMobile ? columns * 3.2 : 0;

      // Calculate cell width: (gridWidth - totalGapWidth - cellPadding) / columns
      const cellWidth = (gridWidth - totalGapWidth - cellPadding) / columns;

      // Font size multipliers based on language (character width relative to font size)
      // These represent the approximate em-width of the longest word in each language
      // Chinese: single character ~1.15em wide
      // Vietnamese: "VANG", "XANH" ~2.6em wide
      // English: "MAGENTA" ~4.2em wide (uppercase)
      // Spanish: "NARANJA", "MAGENTA" ~4.2em wide (uppercase)
      const widthMultipliers = {
        chinese: 1.15,
        vietnamese: 2.6,
        english: 4.2,
        spanish: 4.2
      };

      const multiplier = widthMultipliers[currentLanguage] || 2.5;

      // Dynamic font calculation: (cellWidth * 0.8) / multiplier
      // The 0.8 factor achieves ~80% text width, leaving ~10% margin on each side
      let fontSize = (cellWidth * 0.8) / multiplier;

      // Apply a practical minimum floor (4px is below readable threshold)
      // Font cannot be larger than cell dimensions for fitting
      const minFontSize = 4;
      const maxFontSize = cellWidth * 0.9; // Font shouldn't exceed 90% of cell width

      fontSize = Math.max(minFontSize, Math.min(maxFontSize, fontSize));

      return fontSize;
    }

    // Apply calculated font size to puzzle cells
    function applyPuzzleFontSize() {
      const fontSize = calculatePuzzleFontSize();
      const cells = document.querySelectorAll('.puzzle-cell');
      // Always apply calculated font size for responsive language support
      cells.forEach(cell => cell.style.fontSize = `${fontSize}px`);
    }

    // Render the puzzle grid display (without regenerating data)
    function renderPuzzleDisplay() {
      if (!currentPuzzle) return;

      const grid = document.getElementById('puzzleGrid');
      grid.innerHTML = '';

      currentPuzzle.forEach(cell => {
        const div = document.createElement('div');
        div.className = 'puzzle-cell';
        div.textContent = colorLabelsJson[cell.word][currentLanguage];
        div.style.color = colorsJson[cell.inkColor].variants.base;
        grid.appendChild(div);
      });

      // Apply font size after rendering
      applyPuzzleFontSize();
    }

    // Recalculate font size on window resize
    window.addEventListener('resize', () => {
      if (currentPuzzle) {
        applyPuzzleFontSize();
      }
    });

    // Recalculate font size on orientation change (mobile devices)
    window.addEventListener('orientationchange', () => {
      if (currentPuzzle) {
        // Small delay to allow viewport to update after orientation change
        setTimeout(() => {
          applyPuzzleFontSize();
        }, 100);
      }
    });

    // Store current puzzle metadata for re-rendering
    let currentSeed = 42;
    let currentColorCount = 4;
    let currentCongruentCount = 0;

    // Update metadata display with translated labels
    function updateMetadata() {
      if (!currentPuzzle) return;

      const metaDiv = document.getElementById('metadata');
      metaDiv.textContent = ''; // Clear safely

      // Use dynamic totalCells based on currentGridSize
      const totalCells = currentGridSize * currentGridSize;
      const gridSizeDisplay = `${currentGridSize}x${currentGridSize}`;
      const metaItems = [
        { label: getUIText('metadata_seed'), value: String(currentSeed) },
        { label: getUIText('metadata_colors'), value: String(currentColorCount) },
        { label: getUIText('metadata_grid'), value: gridSizeDisplay },
        { label: getUIText('metadata_congruent'), value: `${currentCongruentCount}/${totalCells} (${(currentCongruentCount/totalCells*100).toFixed(1)}%)` }
      ];

      metaItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'metadata-item';

        const labelSpan = document.createElement('span');
        labelSpan.textContent = item.label;
        div.appendChild(labelSpan);

        const valueSpan = document.createElement('span');
        valueSpan.className = 'metadata-value';
        valueSpan.textContent = item.value;
        div.appendChild(valueSpan);

        metaDiv.appendChild(div);
      });
    }

    // Generate puzzle
    function generatePuzzle() {
      // Reset state
      hasChecked = false;
      answerKeyRevealed = false;
      document.getElementById('answerKeyContent').classList.remove('revealed');
      document.getElementById('revealBtn').textContent = getUIText('reveal_btn');
      document.getElementById('revealWarning').style.display = 'block';
      document.getElementById('resultsSection').classList.remove('visible');
      document.getElementById('checkBtn').disabled = false;

      const seedInput = document.getElementById('seed');
      const congruenceInput = document.getElementById('congruence');
      const colorCountSelect = document.getElementById('colorCount');

      // Apply input sanitization for security
      const seed = sanitizeNumber(seedInput.value, 0, 2147483647, 42);
      const congruencePercent = sanitizeNumber(congruenceInput.value, 0, 100, 12.5);
      const congruence = congruencePercent / 100;
      const colorCount = sanitizeNumber(colorCountSelect.value, 1, 8, 4);

      // Store for metadata re-rendering
      currentSeed = seed;
      currentColorCount = colorCount;

      const random = mulberry32(seed);
      activeColors = COLOR_SUBSETS[colorCount] || COLOR_SUBSETS[2];

      // Create ink distribution (roughly equal with small variations)
      // Use dynamic totalCells based on currentGridSize
      const totalCells = currentGridSize * currentGridSize;
      const basePerColor = Math.floor(totalCells / colorCount);

      // Create base distribution then add random variation
      let inkColors = [];
      let remaining = totalCells;

      activeColors.forEach((token, i) => {
        if (i === activeColors.length - 1) {
          // Last color gets whatever remains
          for (let j = 0; j < remaining; j++) {
            inkColors.push(token);
          }
        } else {
          // Add variation: +/-2 from base, but keep within bounds
          const variation = Math.floor(random() * 5) - 2; // -2 to +2
          const count = Math.max(1, Math.min(basePerColor + 2, basePerColor + variation));
          for (let j = 0; j < count; j++) {
            inkColors.push(token);
          }
          remaining -= count;
        }
      });
      inkColors = shuffle(inkColors, random);

      // Assign words with congruence control
      const cells = inkColors.map(inkColor => {
        let word;
        if (random() < congruence) {
          word = inkColor; // Congruent
        } else {
          // Pick different color from active colors
          const otherColors = activeColors.filter(c => c !== inkColor);
          word = otherColors.length > 0
            ? otherColors[Math.floor(random() * otherColors.length)]
            : inkColor;
        }
        return { word, inkColor };
      });

      currentPuzzle = cells;

      // Update grid CSS for current grid size
      updateGridCSS();

      // Render grid
      renderPuzzleDisplay();

      // Count distribution (correct answers)
      correctAnswers = {};
      let congruentCount = 0;
      cells.forEach(cell => {
        correctAnswers[cell.inkColor] = (correctAnswers[cell.inkColor] || 0) + 1;
        if (cell.word === cell.inkColor) congruentCount++;
      });
      currentCongruentCount = congruentCount;

      // Render answer input grid
      renderAnswerInputs();

      // Render answer key (hidden)
      renderAnswerKey();

      // Update task instructions
      updateTaskInstructions();

      // Render metadata with translated labels
      updateMetadata();
    }

    // Render answer input fields (only active colors)
    function renderAnswerInputs() {
      const answerGrid = document.getElementById('answerGrid');
      answerGrid.textContent = ''; // Clear safely

      // Calculate max input value based on current grid size
      const maxInputValue = currentGridSize * currentGridSize;

      // Only show active colors for this puzzle
      activeColors.forEach(token => {
        const item = document.createElement('div');
        item.className = 'answer-item';
        item.id = `answer-item-${token}`;

        // Create swatch
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = colorsJson[token].variants.base;
        item.appendChild(swatch);

        // Create label
        const label = document.createElement('span');
        label.className = 'answer-label';
        label.textContent = colorLabelsJson[token][currentLanguage];
        item.appendChild(label);

        // Create input
        const input = document.createElement('input');
        input.type = 'number';
        input.className = 'answer-input';
        input.id = `answer-${token}`;
        input.min = '0';
        input.max = String(maxInputValue);
        input.placeholder = '?';
        item.appendChild(input);

        // Create correct value span
        const correctSpan = document.createElement('span');
        correctSpan.className = 'correct-value';
        correctSpan.id = `correct-${token}`;
        item.appendChild(correctSpan);

        answerGrid.appendChild(item);
      });

      // Add enter key handler to check answers
      answerGrid.querySelectorAll('input').forEach(input => {
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            checkAnswers();
          }
        });
      });
    }

    // Render answer key (only active colors, hidden by default)
    function renderAnswerKey() {
      const keyGrid = document.getElementById('answerKeyGrid');
      keyGrid.textContent = ''; // Clear safely

      // Only show active colors for this puzzle
      activeColors.forEach(token => {
        const item = document.createElement('div');
        item.className = 'answer-key-item';

        // Create swatch
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = colorsJson[token].variants.base;
        item.appendChild(swatch);

        // Create label
        const label = document.createElement('span');
        label.className = 'answer-key-label';
        label.textContent = colorLabelsJson[token][currentLanguage];
        item.appendChild(label);

        // Create count
        const count = document.createElement('span');
        count.className = 'answer-key-count';
        count.textContent = String(correctAnswers[token]);
        item.appendChild(count);

        keyGrid.appendChild(item);
      });
    }

    // Check answers
    function checkAnswers() {
      if (!currentPuzzle) return;

      hasChecked = true;
      let correctCount = 0;
      let totalOff = 0;

      // Calculate max value based on current grid size
      const maxValue = currentGridSize * currentGridSize;

      activeColors.forEach(token => {
        const input = document.getElementById(`answer-${token}`);
        const item = document.getElementById(`answer-item-${token}`);
        const correctSpan = document.getElementById(`correct-${token}`);
        // Sanitize user input
        const userAnswer = sanitizeNumber(input.value, 0, maxValue, 0);
        const correct = correctAnswers[token];

        input.classList.remove('correct', 'incorrect');
        item.classList.remove('correct', 'incorrect');

        if (userAnswer === correct) {
          input.classList.add('correct');
          item.classList.add('correct');
          correctSpan.textContent = '';
          correctCount++;
        } else {
          input.classList.add('incorrect');
          item.classList.add('incorrect');
          correctSpan.textContent = correct;
          totalOff += Math.abs(userAnswer - correct);
        }
      });

      // Show results
      showResults(correctCount, activeColors.length, totalOff);
    }

    // Show results with translated messages
    function showResults(correct, total, totalOff) {
      const resultsSection = document.getElementById('resultsSection');
      const resultsSummary = document.getElementById('resultsSummary');
      const resultMessage = document.getElementById('resultMessage');

      const percentage = Math.round((correct / total) * 100);
      let scoreClass, message;

      if (correct === total) {
        scoreClass = 'perfect';
        message = getUIText('result_perfect');
      } else if (percentage >= 75) {
        scoreClass = 'good';
        message = getUIText('result_good')
          .replace('{correct}', String(correct))
          .replace('{total}', String(total));
      } else {
        scoreClass = 'needs-work';
        message = getUIText('result_needs_work')
          .replace('{correct}', String(correct))
          .replace('{total}', String(total));
      }

      // Build results using safe DOM manipulation
      resultsSummary.textContent = ''; // Clear safely

      const stats = [
        { value: `${correct}/${total}`, label: getUIText('result_colors_correct'), hasClass: true },
        { value: `${percentage}%`, label: getUIText('result_accuracy'), hasClass: true },
        { value: String(totalOff), label: getUIText('result_total_off'), hasClass: false }
      ];

      stats.forEach(stat => {
        const div = document.createElement('div');
        div.className = stat.hasClass ? `result-stat ${scoreClass}` : 'result-stat';

        const valueDiv = document.createElement('div');
        valueDiv.className = 'value';
        valueDiv.textContent = stat.value;
        div.appendChild(valueDiv);

        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        labelDiv.textContent = stat.label;
        div.appendChild(labelDiv);

        resultsSummary.appendChild(div);
      });

      resultMessage.className = `result-message ${scoreClass}`;
      resultMessage.textContent = message;

      resultsSection.classList.add('visible');
    }

    // Clear answers
    function clearAnswers() {
      ALL_COLOR_TOKENS.forEach(token => {
        const input = document.getElementById(`answer-${token}`);
        const item = document.getElementById(`answer-item-${token}`);
        const correctSpan = document.getElementById(`correct-${token}`);

        if (input) {
          input.value = '';
          input.classList.remove('correct', 'incorrect');
        }
        if (item) {
          item.classList.remove('correct', 'incorrect');
        }
        if (correctSpan) {
          correctSpan.textContent = '';
        }
      });

      document.getElementById('resultsSection').classList.remove('visible');
      hasChecked = false;
    }

    // Toggle answer key visibility
    function toggleAnswerKey() {
      const content = document.getElementById('answerKeyContent');
      const btn = document.getElementById('revealBtn');
      const warning = document.getElementById('revealWarning');

      if (answerKeyRevealed) {
        content.classList.remove('revealed');
        btn.textContent = getUIText('reveal_btn');
        answerKeyRevealed = false;
        warning.style.display = 'block';
      } else {
        content.classList.add('revealed');
        btn.textContent = getUIText('hide_btn');
        answerKeyRevealed = true;
        warning.style.display = 'none';
      }
    }

    function randomSeed() {
      document.getElementById('seed').value = Math.floor(Math.random() * 1000000);
      generatePuzzle();
    }

    // Wire up event listeners (security: avoid global function exposure)
    document.getElementById('generateBtn').addEventListener('click', generatePuzzle);
    document.getElementById('randomBtn').addEventListener('click', randomSeed);
    document.getElementById('checkBtn').addEventListener('click', checkAnswers);
    document.getElementById('clearBtn').addEventListener('click', clearAnswers);
    document.getElementById('revealBtn').addEventListener('click', toggleAnswerKey);

    // Initialize custom controls visibility based on difficulty
    updateCustomControlsVisibility();

    // Apply difficulty preset if not custom (restores settings on page load)
    if (currentDifficulty !== 'custom') {
      applyDifficultyPreset(currentDifficulty);
    }

    // Initialize color dropdown options based on initial grid size
    updateColorDropdownOptions();

    // Initialize UI text with current language
    updateAllUIText();

    // Initial generation
    generatePuzzle();
  </script>
</body>
</html>
