<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 'self' data: https://lh3.googleusercontent.com; connect-src 'self' https://*.supabase.co;">
  <title>ColorFocus - Stroop Puzzle</title>
  <style>
    /* ========================================
       APPLE-ESQUE DESIGN SYSTEM
       ======================================== */
    :root {
      /* Apple Color Palette */
      --color-bg-page: #F5F5F7;
      --color-bg-card: #FFFFFF;
      --color-bg-surface: #FAFAFA;
      --color-bg-hover: #F0F0F2;

      --color-text-primary: #1D1D1F;
      --color-text-secondary: #86868B;
      --color-text-tertiary: #AEAEB2;

      --color-accent: #0071E3;
      --color-accent-hover: #0077ED;

      --color-border: #E8E8ED;
      --color-border-focus: #0071E3;

      --color-success: #34C759;
      --color-success-bg: #E8F9ED;
      --color-error: #FF3B30;
      --color-error-bg: #FFEFEF;

      --color-warning-bg: #FFF8E6;
      --color-warning-text: #8B6914;
      --color-warning-border: #F5D77A;

      /* Typography */
      --font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --font-weight-normal: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --line-height: 1.5;

      /* Spacing Scale */
      --space-xs: 0.25rem;
      --space-sm: 0.5rem;
      --space-md: 0.75rem;
      --space-lg: 1rem;
      --space-xl: 1.5rem;
      --space-2xl: 2rem;
      --space-3xl: 3rem;

      /* Border Radius */
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 20px;
      --radius-pill: 9999px;

      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
      --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 4px 16px rgba(0, 0, 0, 0.08);
      --shadow-card: 0 2px 12px rgba(0, 0, 0, 0.04);

      /* Transitions */
      --transition-fast: 0.15s ease-out;
      --transition-normal: 0.25s ease-out;
      --transition-slow: 0.35s ease-out;

      /* Component-specific */
      --btn-min-height: 44px;
      --input-min-height: 44px;
      --cell-gap: 4px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family);
      background: var(--color-bg-page);
      padding: var(--space-xl);
      max-width: 900px;
      margin: 0 auto;
      line-height: var(--line-height);
      color: var(--color-text-primary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* Larger base font for elderly users */
      font-size: 1.0625rem;
    }

    /* Skip link for keyboard navigation */
    .skip-link {
      position: absolute;
      top: -100px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--color-accent);
      color: white;
      padding: var(--space-md) var(--space-xl);
      border-radius: var(--radius-pill);
      font-weight: var(--font-weight-medium);
      z-index: 9999;
      text-decoration: none;
    }
    .skip-link:focus {
      top: var(--space-md);
    }

    h1 {
      font-size: 2rem;
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--space-sm);
      letter-spacing: -0.02em;
      color: var(--color-text-primary);
    }
    .subtitle {
      color: var(--color-text-secondary);
      margin-bottom: var(--space-lg);
      font-size: 1rem;
      font-weight: var(--font-weight-normal);
    }
    .donation-link {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--color-warning-text);
      font-size: 0.8125rem;
      font-weight: var(--font-weight-medium);
      text-decoration: none;
      padding: var(--space-sm) var(--space-md);
      background: var(--color-warning-bg);
      border-radius: var(--radius-md);
      min-height: var(--btn-min-height);
      border: 1px solid var(--color-warning-border);
      transition: all var(--transition-normal);
    }
    .donation-link:hover {
      background: #FFF3D6;
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }
    .donation-link:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(139, 105, 20, 0.2);
    }
    /* Auth Section Styles */
    .auth-section {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      margin-bottom: var(--space-xl);
    }
    .auth-btn {
      padding: var(--space-md) var(--space-lg);
      background: var(--color-accent);
      color: white;
      border: none;
      border-radius: var(--radius-pill);
      font-size: 0.875rem;
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: all var(--transition-normal);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      min-height: var(--btn-min-height);
    }
    .auth-btn:hover {
      background: var(--color-accent-hover);
      transform: scale(1.02);
    }
    .auth-btn:active {
      transform: scale(0.98);
    }
    .auth-btn.secondary {
      background: var(--color-bg-surface);
      color: var(--color-text-primary);
      border: 1px solid var(--color-border);
    }
    .auth-btn.secondary:hover {
      background: var(--color-bg-hover);
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }
    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid var(--color-border);
    }
    .user-name {
      font-size: 0.875rem;
      color: var(--color-text-primary);
      font-weight: var(--font-weight-medium);
      max-width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .controls {
      display: flex;
      gap: var(--space-lg);
      margin-bottom: var(--space-xl);
      flex-wrap: wrap;
      align-items: center;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }
    label {
      font-size: 0.8125rem;
      color: var(--color-text-secondary);
      font-weight: var(--font-weight-medium);
    }
    input[type="number"], select {
      width: 70px;
      padding: var(--space-md) var(--space-lg);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      font-size: 0.875rem;
      background: var(--color-bg-card);
      color: var(--color-text-primary);
      min-height: var(--input-min-height);
      transition: all var(--transition-fast);
    }
    input[type="number"]:hover, select:hover {
      border-color: var(--color-text-tertiary);
    }
    input[type="number"]:focus, select:focus {
      outline: none;
      border-color: var(--color-accent);
      box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.15);
    }
    select {
      width: auto;
    }
    button {
      padding: var(--space-md) var(--space-xl);
      background: var(--color-accent);
      color: white;
      border: none;
      border-radius: var(--radius-pill);
      font-size: 0.875rem;
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: all var(--transition-normal);
      min-height: var(--btn-min-height);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
    }
    button:hover {
      background: var(--color-accent-hover);
      transform: scale(1.02);
    }
    button:active {
      transform: scale(0.98);
    }
    button:focus-visible {
      outline: 2px solid var(--color-accent);
      outline-offset: 2px;
    }
    button:disabled {
      background: var(--color-border);
      color: var(--color-text-tertiary);
      cursor: not-allowed;
      transform: none;
    }
    button.secondary {
      background: var(--color-bg-surface);
      color: var(--color-text-primary);
      border: 1px solid var(--color-border);
    }
    button.secondary:hover {
      background: var(--color-bg-hover);
      border-color: var(--color-text-tertiary);
    }
    button.success {
      background: var(--color-success);
    }
    button.success:hover {
      background: #2DB84E;
    }
    .puzzle-container {
      background: var(--color-bg-card);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-card);
      margin-bottom: var(--space-xl);
    }
    .puzzle-controls {
      display: flex;
      gap: var(--space-md);
      margin-bottom: var(--space-lg);
      flex-wrap: wrap;
      align-items: center;
    }
    .puzzle-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: var(--cell-gap);
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      padding: var(--space-sm);
      background: var(--color-bg-page);
      border-radius: var(--radius-md);
    }
    .puzzle-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.75rem 0.5rem;
      font-weight: var(--font-weight-semibold);
      border-radius: var(--radius-sm);
      background: var(--color-bg-card);
      border: none;
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-normal);
      cursor: pointer;
    }
    .puzzle-cell:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
      z-index: 1;
    }
    .puzzle-cell.selected {
      background: var(--color-bg-hover);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.08);
      transform: none;
    }
    .puzzle-cell.selected:hover {
      transform: none;
    }
    .puzzle-cell:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.3);
      z-index: 2;
    }
    .puzzle-cell.selected:focus {
      background: var(--color-bg-hover);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.08), 0 0 0 3px rgba(0, 113, 227, 0.3);
    }
    .metadata {
      display: flex;
      gap: var(--space-2xl);
      margin-top: var(--space-lg);
      padding-top: var(--space-lg);
      border-top: 1px solid var(--color-border);
      font-size: 0.8125rem;
      color: var(--color-text-secondary);
      flex-wrap: wrap;
    }
    .metadata-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }
    .metadata-value {
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
    }

    /* Sound toggle checkbox styling */
    .sound-toggle-group {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }
    .sound-toggle-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: var(--color-accent);
    }
    .sound-toggle-group label {
      cursor: pointer;
    }

    /* Answer Submission Section */
    .answer-section {
      background: var(--color-bg-card);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-card);
      margin-bottom: var(--space-xl);
    }
    .answer-section h2 {
      font-size: 1rem;
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--space-lg);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      color: var(--color-text-primary);
    }
    .answer-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--space-lg);
      margin-bottom: var(--space-xl);
    }
    @media (max-width: 600px) {
      .answer-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    .answer-item {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-md) var(--space-lg);
      border-radius: var(--radius-md);
      background: var(--color-bg-surface);
      transition: all var(--transition-normal);
      border: 1px solid transparent;
      min-width: 0;
      overflow: hidden;
    }
    .answer-item.correct {
      background: var(--color-success-bg);
      border-color: var(--color-success);
    }
    .answer-item.incorrect {
      background: var(--color-error-bg);
      border-color: var(--color-error);
    }
    .color-swatch {
      width: 28px;
      height: 28px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--color-border);
      flex-shrink: 0;
      cursor: pointer;
      transition: all var(--transition-fast);
    }
    .color-swatch:hover {
      transform: scale(1.1);
      box-shadow: var(--shadow-md);
    }
    .color-swatch:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.3);
    }
    .answer-label {
      font-size: 0.875rem;
      font-weight: var(--font-weight-medium);
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--color-text-primary);
    }
    .answer-input {
      width: 56px;
      padding: var(--space-sm) var(--space-md);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      font-size: 0.9375rem;
      text-align: center;
      font-weight: var(--font-weight-semibold);
      background: var(--color-bg-card);
      transition: all var(--transition-fast);
    }
    .answer-input:focus {
      outline: none;
      border-color: var(--color-accent);
      box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.15);
    }
    .answer-input.correct {
      border-color: var(--color-success);
      background: var(--color-success-bg);
    }
    .answer-input.incorrect {
      border-color: var(--color-error);
      background: var(--color-error-bg);
    }
    .correct-value {
      font-size: 0.8125rem;
      color: var(--color-success);
      font-weight: var(--font-weight-semibold);
      min-width: 30px;
      text-align: center;
    }
    .answer-buttons {
      display: flex;
      gap: var(--space-md);
      flex-wrap: wrap;
    }

    /* Results Section */
    .results-section {
      background: var(--color-bg-card);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-card);
      margin-bottom: var(--space-xl);
      display: none;
    }
    .results-section.visible {
      display: block;
    }
    .results-section h2 {
      font-size: 1rem;
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--space-lg);
      color: var(--color-text-primary);
    }
    .results-summary {
      display: flex;
      gap: var(--space-3xl);
      margin-bottom: var(--space-xl);
      flex-wrap: wrap;
    }
    .result-stat {
      text-align: center;
    }
    .result-stat .value {
      font-size: 2.5rem;
      font-weight: var(--font-weight-semibold);
      line-height: 1;
      letter-spacing: -0.02em;
    }
    .result-stat .label {
      font-size: 0.8125rem;
      color: var(--color-text-secondary);
      margin-top: var(--space-sm);
      font-weight: var(--font-weight-medium);
    }
    .result-stat.perfect .value {
      color: var(--color-success);
    }
    .result-stat.good .value {
      color: var(--color-accent);
    }
    .result-stat.needs-work .value {
      color: var(--color-error);
    }
    .result-message {
      padding: var(--space-lg) var(--space-xl);
      border-radius: var(--radius-md);
      font-size: 0.9375rem;
      font-weight: var(--font-weight-medium);
    }
    .result-message.perfect {
      background: var(--color-success-bg);
      color: #1A7F37;
    }
    .result-message.good {
      background: #E8F4FD;
      color: #0055B3;
    }
    .result-message.needs-work {
      background: var(--color-error-bg);
      color: #CC2F26;
    }

    /* Answer Key Section (Hidden by Default) */
    .answer-key-section {
      background: var(--color-bg-card);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-card);
    }
    .answer-key-section h2 {
      font-size: 1rem;
      font-weight: var(--font-weight-semibold);
      margin-bottom: var(--space-lg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: var(--color-text-primary);
    }
    .answer-key-content {
      display: none;
    }
    .answer-key-content.revealed {
      display: block;
    }
    .answer-key-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--space-md);
    }
    .answer-key-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      font-size: 0.875rem;
      padding: var(--space-md);
      background: var(--color-bg-surface);
      border-radius: var(--radius-sm);
    }
    .answer-key-label {
      flex: 1;
      color: var(--color-text-primary);
    }
    .answer-key-count {
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
    }
    .reveal-warning {
      background: var(--color-warning-bg);
      padding: var(--space-md) var(--space-lg);
      border-radius: var(--radius-sm);
      font-size: 0.875rem;
      color: var(--color-warning-text);
      margin-bottom: var(--space-lg);
      border: 1px solid var(--color-warning-border);
    }

    /* Donation QR Code Section */
    .donation-section {
      background: var(--color-bg-card);
      border-radius: var(--radius-lg);
      padding: var(--space-xl);
      box-shadow: var(--shadow-card);
      text-align: center;
      margin-top: var(--space-xl);
    }
    .donation-qr {
      width: 140px;
      height: auto;
      display: block;
      margin: 0 auto var(--space-md) auto;
      border-radius: var(--radius-sm);
    }
    .donation-label {
      color: var(--color-text-secondary);
      font-size: 0.875rem;
      margin: 0;
    }

    /* Custom controls visibility (shown only in Custom difficulty) */
    .custom-control {
      display: none;
    }
    .custom-control.visible {
      display: flex;
    }

    /* ========================================
       MODAL SYSTEM
       ======================================== */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-normal), visibility var(--transition-normal);
      z-index: 1000;
    }
    .modal-backdrop.visible {
      opacity: 1;
      visibility: visible;
    }
    .modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background: var(--color-bg-card);
      border-radius: var(--radius-xl);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      width: 90%;
      max-width: 480px;
      max-height: 85vh;
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-normal);
      z-index: 1001;
    }
    .modal.visible {
      opacity: 1;
      visibility: visible;
      transform: translate(-50%, -50%) scale(1);
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-lg) var(--space-xl);
      border-bottom: 1px solid var(--color-border);
    }
    .modal-title {
      font-size: 1.125rem;
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      margin: 0;
    }
    .modal-close {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--color-bg-surface);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      min-height: auto;
      color: var(--color-text-secondary);
      transition: all var(--transition-fast);
    }
    .modal-close:hover {
      background: var(--color-bg-hover);
      color: var(--color-text-primary);
      transform: none;
    }
    .modal-close:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.3);
    }
    .modal-close:focus-visible {
      outline: 2px solid var(--color-accent);
      outline-offset: 2px;
    }
    .modal-close svg {
      width: 16px;
      height: 16px;
    }
    .modal-body {
      padding: var(--space-xl);
      overflow-y: auto;
      max-height: calc(85vh - 65px);
    }
    .modal-section {
      margin-bottom: var(--space-xl);
    }
    .modal-section:last-child {
      margin-bottom: 0;
    }
    .modal-section-title {
      font-size: 0.75rem;
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: var(--space-md);
    }
    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-md) 0;
      border-bottom: 1px solid var(--color-border);
      gap: var(--space-md);
    }
    .settings-row:last-child {
      border-bottom: none;
    }
    .settings-label {
      font-size: 0.9375rem;
      color: var(--color-text-primary);
      flex: 1;
    }
    .settings-row select,
    .settings-row input[type="number"] {
      min-width: 120px;
    }

    /* iOS-style Toggle Switch */
    .toggle-switch {
      position: relative;
      width: 51px;
      height: 31px;
      flex-shrink: 0;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: var(--color-border);
      border-radius: 31px;
      transition: background var(--transition-fast);
    }
    .toggle-slider::before {
      content: '';
      position: absolute;
      height: 27px;
      width: 27px;
      left: 2px;
      bottom: 2px;
      background: white;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: transform var(--transition-fast);
    }
    .toggle-switch input:checked + .toggle-slider {
      background: var(--color-success);
    }
    .toggle-switch input:checked + .toggle-slider::before {
      transform: translateX(20px);
    }
    .toggle-switch input:focus + .toggle-slider {
      box-shadow: 0 0 0 3px rgba(0, 113, 227, 0.15);
    }

    /* Icon Buttons for Settings/About */
    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      padding: var(--space-sm) var(--space-md);
      background: var(--color-bg-surface);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-sm);
      color: var(--color-text-secondary);
      font-size: 0.8125rem;
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: all var(--transition-fast);
      min-height: var(--btn-min-height);
    }
    .icon-btn:hover {
      background: var(--color-bg-hover);
      color: var(--color-text-primary);
      border-color: var(--color-text-tertiary);
      transform: none;
    }
    .icon-btn svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }
    .icon-btn-text {
      display: inline;
    }

    /* About Modal Specific Styles */
    .about-header {
      text-align: center;
      margin-bottom: var(--space-xl);
    }
    .about-icon {
      width: 64px;
      height: 64px;
      background: linear-gradient(135deg, var(--color-accent), #5856D6);
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto var(--space-md);
      color: white;
      font-size: 1.75rem;
      font-weight: var(--font-weight-semibold);
    }
    .about-tagline {
      color: var(--color-text-secondary);
      font-size: 0.9375rem;
      margin: 0;
    }
    .about-section {
      margin-bottom: var(--space-xl);
    }
    .about-section-title {
      font-size: 1rem;
      font-weight: var(--font-weight-semibold);
      color: var(--color-text-primary);
      margin-bottom: var(--space-sm);
    }
    .about-text {
      font-size: 0.9375rem;
      color: var(--color-text-secondary);
      line-height: 1.6;
      margin: 0;
    }
    .about-story {
      background: var(--color-bg-surface);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      font-size: 0.875rem;
      color: var(--color-text-secondary);
      line-height: 1.6;
      border-left: 3px solid var(--color-accent);
    }
    .about-story p {
      margin: 0 0 0.75em 0;
    }
    .about-story p:last-child {
      margin-bottom: 0;
    }
    .about-footer {
      text-align: center;
      padding-top: var(--space-lg);
      border-top: 1px solid var(--color-border);
    }
    .about-link {
      color: var(--color-accent);
      text-decoration: none;
      font-size: 0.875rem;
      font-weight: var(--font-weight-medium);
    }
    .about-link:hover {
      text-decoration: underline;
    }

    /* Controls layout with icon buttons */
    .controls-main {
      display: flex;
      gap: var(--space-md);
      flex-wrap: wrap;
      align-items: center;
    }
    .controls-actions {
      display: flex;
      gap: var(--space-sm);
      margin-left: auto;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 480px) {
      body {
        padding: var(--space-md);
        max-width: 100%;
      }
      h1 {
        font-size: 1.35rem;
      }
      .subtitle {
        font-size: 0.85rem;
      }
      .donation-link {
        font-size: 0.75rem;
        padding: var(--space-xs) var(--space-sm);
      }
      .auth-section {
        flex-wrap: wrap;
        gap: var(--space-xs);
      }
      .auth-btn {
        font-size: 0.8rem;
        padding: var(--space-xs) var(--space-sm);
        min-height: var(--btn-min-height);
      }
      .user-avatar {
        width: 28px;
        height: 28px;
      }
      .user-name {
        font-size: 0.8rem;
        max-width: 100px;
      }
      .controls {
        gap: var(--space-sm);
      }
      .control-group {
        gap: var(--space-xs);
      }
      label {
        font-size: 0.75rem;
      }
      input[type="number"], select {
        width: 60px;
        padding: var(--space-xs);
        font-size: 0.8rem;
        min-height: var(--btn-min-height);
      }
      button {
        padding: var(--space-xs) var(--space-sm);
        font-size: 0.8rem;
      }
      .puzzle-container {
        padding: var(--space-sm);
        overflow-x: hidden;
      }
      .puzzle-controls {
        gap: var(--space-xs);
      }
      .puzzle-grid {
        gap: 2px;
        width: 100%;
      }
      .puzzle-cell {
        border-radius: var(--radius-xs);
        padding: 0.1rem;
        overflow: hidden;
        text-overflow: clip;
      }
      .puzzle-cell:hover {
        transform: none;
        box-shadow: var(--shadow-sm);
      }
      .puzzle-cell.selected {
        background: var(--color-bg-selected);
        box-shadow: var(--shadow-inset);
        transform: none;
      }
      .puzzle-cell.selected:hover {
        transform: none;
      }
      .puzzle-cell:focus {
        outline: 2px solid var(--color-accent);
        outline-offset: 1px;
      }
      .puzzle-cell.selected:focus {
        background: var(--color-bg-selected);
        box-shadow: var(--shadow-inset);
        transform: none;
        outline: 2px solid var(--color-accent);
        outline-offset: 1px;
      }
      .metadata {
        gap: var(--space-md);
        font-size: 0.75rem;
        justify-content: center;
      }
      .answer-section {
        padding: var(--space-md);
      }
      .answer-section h2 {
        font-size: 0.9rem;
      }
      .answer-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: var(--space-sm);
      }
      .answer-item {
        padding: var(--space-xs);
        gap: var(--space-xs);
      }
      .color-swatch {
        width: 20px;
        height: 20px;
      }
      .answer-label {
        font-size: 0.8rem;
      }
      .answer-input {
        width: 44px;
        padding: var(--space-xs);
        font-size: 0.85rem;
        min-height: var(--btn-min-height);
      }
      .correct-value {
        font-size: 0.7rem;
        min-width: 22px;
      }
      .answer-buttons {
        width: 100%;
      }
      .answer-buttons button {
        flex: 1;
        min-width: 0;
      }
      .results-section {
        padding: var(--space-md);
      }
      .results-summary {
        gap: var(--space-lg);
        justify-content: center;
      }
      .result-stat .value {
        font-size: 1.5rem;
      }
      .result-stat .label {
        font-size: 0.7rem;
      }
      .result-message {
        font-size: 0.8rem;
        padding: var(--space-sm);
      }
      .answer-key-section {
        padding: var(--space-md);
      }
      .answer-key-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: var(--space-xs);
      }
      .answer-key-item {
        font-size: 0.75rem;
        padding: var(--space-xs);
      }
      .reveal-warning {
        font-size: 0.75rem;
        padding: var(--space-xs);
      }
      .donation-section {
        padding: var(--space-md);
      }
      .donation-qr {
        width: 120px;
      }
      .donation-label {
        font-size: 0.8rem;
      }
      .sound-toggle-group input[type="checkbox"] {
        width: 20px;
        height: 20px;
      }
      /* Modal mobile styles */
      .modal {
        width: 100%;
        max-width: 100%;
        max-height: 90vh;
        top: auto;
        bottom: 0;
        left: 0;
        transform: translateY(100%);
        border-radius: var(--radius-xl) var(--radius-xl) 0 0;
      }
      .modal.visible {
        transform: translateY(0);
      }
      .modal-body {
        max-height: calc(90vh - 65px);
        padding: var(--space-lg);
      }
      .icon-btn-text {
        display: none;
      }
      .icon-btn {
        padding: var(--space-sm);
      }
      .controls-actions {
        margin-left: 0;
        gap: var(--space-xs);
      }
      .about-story {
        padding: var(--space-md);
        font-size: 0.8125rem;
      }
      .toggle-switch {
        width: 44px;
        height: 26px;
      }
      .toggle-slider::before {
        height: 22px;
        width: 22px;
      }
      .toggle-switch input:checked + .toggle-slider::before {
        transform: translateX(18px);
      }
    }

    /* Extra small devices (iPhone SE, etc.) */
    @media (max-width: 375px) {
      body {
        padding: var(--space-sm);
      }
      h1 {
        font-size: 1.2rem;
      }
      .puzzle-cell {
        font-size: 1.25rem;
      }
      .controls {
        justify-content: center;
      }
      input[type="number"], select {
        width: 55px;
      }
      .donation-qr {
        width: 100px;
      }
      .donation-label {
        font-size: 0.75rem;
      }
      .user-name {
        display: none;
      }
    }

    /* High contrast mode support */
    @media (prefers-contrast: high) {
      :root {
        --color-border: #1D1D1F;
        --color-text-secondary: #1D1D1F;
      }
      .puzzle-cell {
        border: 2px solid var(--color-text-primary);
      }
    }

    /* Reduced motion for vestibular disorders */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
  </style>
</head>
<body>
  <a href="#puzzleGrid" class="skip-link">Skip to puzzle</a>
  <h1 id="pageTitle">ColorFocus Stroop Puzzle</h1>
  <p class="subtitle" id="subtitle">Count the INK colors, not the word meanings!</p>

  <!-- Auth Section -->
  <div class="auth-section" id="authSection">
    <button id="loginBtn" class="auth-btn" data-i18n="signin_btn">Sign in with Google</button>
    <div id="userInfo" class="user-info" style="display: none;">
      <img id="userAvatar" class="user-avatar" alt="User avatar" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2394a3b8'%3E%3Ccircle cx='12' cy='8' r='4'/%3E%3Cpath d='M12 14c-6 0-8 3-8 6v1h16v-1c0-3-2-6-8-6z'/%3E%3C/svg%3E">
      <span id="userName" class="user-name"></span>
      <button id="logoutBtn" class="auth-btn secondary" data-i18n="signout_btn">Sign out</button>
    </div>
  </div>

  <div class="controls">
    <div class="controls-main">
      <button id="generateBtn">Generate</button>
      <button id="randomBtn" class="secondary">Random</button>
    </div>
    <div class="controls-actions">
      <a href="https://buymeacoffee.com/xwje4mbv3l"
         target="_blank"
         rel="noopener noreferrer"
         class="donation-link"
         id="donationLink"
         data-i18n="support_link_text">Support</a>
      <button class="icon-btn" id="settingsBtn" aria-label="Open settings">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
        <span class="icon-btn-text" id="settingsBtnText">Settings</span>
      </button>
      <button class="icon-btn" id="aboutBtn" aria-label="Help and About">
        <span style="font-size: 1.125rem; font-weight: 600;">?</span>
      </button>
    </div>
  </div>

  <!-- Hidden original controls for state management -->
  <div style="display: none;">
    <select id="difficulty">
      <option value="accessible">Accessible</option>
      <option value="standard" selected>Standard</option>
      <option value="advanced">Advanced</option>
      <option value="custom">Custom</option>
    </select>
    <select id="language">
      <option value="zh-TW" selected>Chinese</option>
      <option value="english">English</option>
      <option value="spanish">Spanish</option>
      <option value="vietnamese">Vietnamese</option>
    </select>
    <select id="spacing">
      <option value="compact">Compact</option>
      <option value="normal" selected>Normal</option>
      <option value="relaxed">Relaxed</option>
      <option value="spacious">Spacious</option>
    </select>
    <select id="gridSize">
      <option value="1">1x1</option>
      <option value="2">2x2</option>
      <option value="3">3x3</option>
      <option value="4" selected>4x4</option>
      <option value="5">5x5</option>
      <option value="6">6x6</option>
      <option value="7">7x7</option>
      <option value="8">8x8</option>
    </select>
    <select id="colorCount">
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4" selected>4</option>
      <option value="5">5</option>
      <option value="6">6</option>
      <option value="7">7</option>
      <option value="8">8</option>
    </select>
    <input type="number" id="congruence" value="12.5" min="0" max="100" step="0.1">
    <input type="number" id="seed" value="42" min="0">
    <input type="checkbox" id="soundToggle">
  </div>

  <div class="puzzle-container">
    <div class="puzzle-controls">
      <button id="clearSelectionsBtn" class="secondary" data-i18n="clear_selections_btn">Clear Selections</button>
    </div>
    <div class="puzzle-grid" id="puzzleGrid" role="grid" aria-label="Color puzzle grid"></div>
    <div class="metadata" id="metadata"></div>
  </div>

  <!-- Answer Submission Section -->
  <div class="answer-section">
    <h2 id="enterAnswersHeader">Enter Your Answers</h2>
    <div class="answer-grid" id="answerGrid"></div>
    <div class="answer-buttons">
      <button class="success" id="checkBtn">Check Answers</button>
      <button class="secondary" id="clearBtn">Clear</button>
    </div>
  </div>

  <!-- Results Section -->
  <div class="results-section" id="resultsSection">
    <h2 id="resultsHeader">Results</h2>
    <div class="results-summary" id="resultsSummary"></div>
    <div class="result-message" id="resultMessage"></div>
  </div>

  <!-- Answer Key Section (Hidden by Default) -->
  <div class="answer-key-section">
    <h2>
      <span id="answerKeyHeader">Answer Key</span>
      <button class="secondary" id="revealBtn">Reveal</button>
    </h2>
    <div class="reveal-warning" id="revealWarning">
      Revealing the answer key will end your current attempt. Check your answers first!
    </div>
    <div class="answer-key-content" id="answerKeyContent">
      <div class="answer-key-grid" id="answerKeyGrid"></div>
    </div>
  </div>

  <!-- Donation QR Code Section -->
  <div class="donation-section">
    <a href="https://buymeacoffee.com/xwje4mbv3l" target="_blank" rel="noopener noreferrer">
      <img src="/frontend/bmc_qr.png" alt="QR code to support ColorFocus via Buy Me A Coffee" class="donation-qr">
    </a>
    <p class="donation-label" id="donationLabel" data-i18n="qr_code_label">Scan to support ColorFocus</p>
  </div>

  <!-- Modal Backdrop -->
  <div class="modal-backdrop" id="modalBackdrop"></div>

  <!-- Settings Modal -->
  <div class="modal" id="settingsModal" role="dialog" aria-labelledby="settingsModalTitle" aria-modal="true">
    <div class="modal-header">
      <h2 class="modal-title" id="settingsModalTitle">Settings</h2>
      <button class="modal-close" id="settingsModalClose" aria-label="Close settings">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="modal-body">
      <!-- Display Section -->
      <div class="modal-section">
        <div class="modal-section-title" id="settingsDisplayTitle">Display</div>
        <div class="settings-row">
          <label class="settings-label" for="modalLanguage" id="modalLanguageLabel">Language</label>
          <select id="modalLanguage" aria-label="Select display language">
            <option value="zh-TW">Chinese</option>
            <option value="english">English</option>
            <option value="spanish">Spanish</option>
            <option value="vietnamese">Vietnamese</option>
          </select>
        </div>
        <div class="settings-row">
          <label class="settings-label" for="modalSpacing" id="modalSpacingLabel">Spacing</label>
          <select id="modalSpacing" aria-label="Select grid spacing">
            <option value="compact">Compact</option>
            <option value="normal">Normal</option>
            <option value="relaxed">Relaxed</option>
            <option value="spacious">Spacious</option>
          </select>
        </div>
        <div class="settings-row">
          <span class="settings-label" id="modalSoundLabel">Selection Sound</span>
          <label class="toggle-switch">
            <input type="checkbox" id="modalSoundToggle" aria-label="Toggle selection sound">
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>

      <!-- Puzzle Section -->
      <div class="modal-section">
        <div class="modal-section-title" id="settingsPuzzleTitle">Puzzle</div>
        <div class="settings-row">
          <label class="settings-label" for="modalDifficulty" id="modalDifficultyLabel">Difficulty</label>
          <select id="modalDifficulty" aria-label="Select difficulty tier">
            <option value="accessible">Accessible</option>
            <option value="standard">Standard</option>
            <option value="advanced">Advanced</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div class="settings-row custom-control" id="modalGridSizeGroup">
          <label class="settings-label" for="modalGridSize" id="modalGridLabel">Grid Size</label>
          <select id="modalGridSize" aria-label="Select grid size">
            <option value="1">1x1</option>
            <option value="2">2x2</option>
            <option value="3">3x3</option>
            <option value="4">4x4</option>
            <option value="5">5x5</option>
            <option value="6">6x6</option>
            <option value="7">7x7</option>
            <option value="8">8x8</option>
          </select>
        </div>
        <div class="settings-row custom-control" id="modalColorCountGroup">
          <label class="settings-label" for="modalColorCount" id="modalColorsLabel">Colors</label>
          <select id="modalColorCount">
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
          </select>
        </div>
        <div class="settings-row custom-control" id="modalCongruenceGroup">
          <label class="settings-label" for="modalCongruence" id="modalMatchLabel">Match %</label>
          <input type="number" id="modalCongruence" value="12.5" min="0" max="100" step="0.1">
        </div>
        <div class="settings-row">
          <label class="settings-label" for="modalSeed" id="modalSeedLabel">Seed</label>
          <input type="number" id="modalSeed" value="42" min="0">
        </div>
      </div>
    </div>
  </div>

  <!-- About Modal -->
  <div class="modal" id="aboutModal" role="dialog" aria-labelledby="aboutModalTitle" aria-modal="true">
    <div class="modal-header">
      <h2 class="modal-title" id="aboutModalTitle">About</h2>
      <button class="modal-close" id="aboutModalClose" aria-label="Close about">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="modal-body">
      <div class="about-header">
        <div class="about-icon">CF</div>
        <p class="about-tagline" id="aboutTagline">Cognitive training through Stroop interference puzzles</p>
      </div>

      <div class="about-section">
        <h3 class="about-section-title" id="aboutHowToPlayTitle">How to Play</h3>
        <p class="about-text" id="aboutHowToPlayText">Count how many cells are printed in each INK color. The word shows a color name, but you must count the actual ink color used to display it. Tip: Click tiles to select them, then click the color swatch in Enter Your Answers to auto-fill the count. Use Clear Selections to deselect all.</p>
      </div>

      <div class="about-section">
        <h3 class="about-section-title" id="aboutWhatTitle">What is ColorFocus?</h3>
        <p class="about-text" id="aboutWhatText">ColorFocus uses the Stroop effect to exercise your brain. When you see a color word printed in a different ink color, your brain must resolve the conflict between reading the word and identifying the ink color. This cognitive challenge helps strengthen attention and processing speed.</p>
      </div>

      <div class="about-section">
        <h3 class="about-section-title" id="aboutStoryTitle">Our Story</h3>
        <div class="about-story" id="aboutStoryText">
          This app was inspired by my mother, who suffered a minor stroke days before Thanksgiving 2025. After initial recovery, she passed all hospital tests, but we wanted to check for subtle cognitive changes. Remembering the Stroop Test from my college Perception and Cognition course, I created a 9x9 puzzle with colored Chinese words (her native language) to test if her language and perception centers were affected.
          <br><br>
          She immediately had difficulty with two adjacent tiles showing incongruent red/green characters. After explaining the Stroop effect and how it detects task interference, she used the puzzles for mental exercise. The next day, the effect was reduced—and soon disappeared entirely.
          <br><br>
          I built this app hoping other stroke survivors can identify similar challenges and rehabilitate the way my mom did. Even if you're not recovering from a stroke, this can be a fun cognitive exercise. I'd love to hear your story—please reach out!
        </div>
      </div>

      <div class="about-footer">
        <a href="https://buymeacoffee.com/xwje4mbv3l" target="_blank" rel="noopener noreferrer" class="about-link" id="aboutSupportLink">Support ColorFocus</a>
      </div>
    </div>
  </div>

  <script type="module">
    // ===========================================
    // SUPABASE AUTH CONFIGURATION
    // ===========================================
    // Import Supabase client from CDN (ESM)
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm'

    // Supabase configuration
    // TODO: Replace with your Supabase project URL and anon key
    const SUPABASE_URL = 'YOUR_SUPABASE_PROJECT_URL'
    const SUPABASE_ANON_KEY = 'YOUR_SUPABASE_ANON_KEY'

    // Initialize Supabase client (only if configured)
    const supabaseConfigured = SUPABASE_URL !== 'YOUR_SUPABASE_PROJECT_URL'
    const supabase = supabaseConfigured ? createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: true,
        storage: window.sessionStorage,
        flowType: 'pkce'
      }
    }) : null

    // ===========================================
    // JSON DATA LOADING
    // ===========================================
    // Load JSON files via fetch for better iOS Safari compatibility
    // (ES module import attributes can fail to fully parse large JSON on some iOS versions)
    async function loadJSON(path) {
      const response = await fetch(path);
      if (!response.ok) throw new Error(`Failed to load ${path}`);
      return response.json();
    }

    const [colorsJson, colorLabelsJson, uiTextJson] = await Promise.all([
      loadJSON('/shared/colors.json'),
      loadJSON('/shared/color_labels.json'),
      loadJSON('/shared/ui_text.json')
    ]);

    // All color tokens in luminance order (accessible color palette)
    // BLACK (10%) -> BROWN (28%) -> PURPLE (35%) -> BLUE (38%) -> GRAY (50%) -> PINK (52%) -> ORANGE (62%) -> YELLOW (84%)
    const ALL_COLOR_TOKENS = ['BLACK', 'BROWN', 'PURPLE', 'BLUE', 'GRAY', 'PINK', 'ORANGE', 'YELLOW'];

    // Color subsets by count (ordered by luminance contrast for accessibility)
    // Accessible tier (2): Maximum contrast - BLACK and YELLOW
    // Standard tier (4): Balanced difficulty - BLACK, BLUE, ORANGE, YELLOW
    // Advanced tier (8): Full palette
    const COLOR_SUBSETS = {
      2: ['BLACK', 'YELLOW'],
      3: ['BLACK', 'BLUE', 'YELLOW'],
      4: ['BLACK', 'BLUE', 'ORANGE', 'YELLOW'],
      5: ['BLACK', 'PURPLE', 'BLUE', 'ORANGE', 'YELLOW'],
      6: ['BLACK', 'PURPLE', 'BLUE', 'PINK', 'ORANGE', 'YELLOW'],
      7: ['BLACK', 'BROWN', 'PURPLE', 'BLUE', 'PINK', 'ORANGE', 'YELLOW'],
      8: ALL_COLOR_TOKENS,
    };

    // Valid language values for input validation
    const VALID_LANGUAGES = ['zh-TW', 'english', 'spanish', 'vietnamese'];

    // Valid grid sizes (1-8)
    const VALID_GRID_SIZES = [1, 2, 3, 4, 5, 6, 7, 8];

    // Valid difficulty tiers
    const VALID_DIFFICULTIES = ['accessible', 'standard', 'advanced', 'custom'];

    // Valid spacing options
    const VALID_SPACINGS = ['compact', 'normal', 'relaxed', 'spacious'];

    // Difficulty tier presets: { gridSize, colorCount, congruencePercent }
    const DIFFICULTY_PRESETS = {
      accessible: { gridSize: 3, colorCount: 2, congruencePercent: 50 },
      standard: { gridSize: 4, colorCount: 4, congruencePercent: 12.5 },
      advanced: { gridSize: 8, colorCount: 8, congruencePercent: 0 }
    };

    // Spacing presets: gap in pixels
    const SPACING_VALUES = {
      compact: 1,
      normal: 2,
      relaxed: 6,
      spacious: 12
    };

    // Sanitize text content to prevent XSS (escapes HTML entities)
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Validate and sanitize numeric input
    function sanitizeNumber(value, min, max, defaultValue) {
      const num = parseFloat(value);
      if (isNaN(num)) return defaultValue;
      return Math.max(min, Math.min(max, num));
    }

    // Validate language selection
    function validateLanguage(lang) {
      return VALID_LANGUAGES.includes(lang) ? lang : 'zh-TW';
    }

    // Validate grid size selection
    function validateGridSize(size) {
      const num = parseInt(size, 10);
      return VALID_GRID_SIZES.includes(num) ? num : 4;
    }

    // Validate difficulty selection
    function validateDifficulty(difficulty) {
      return VALID_DIFFICULTIES.includes(difficulty) ? difficulty : 'standard';
    }

    // Validate spacing selection
    function validateSpacing(spacing) {
      return VALID_SPACINGS.includes(spacing) ? spacing : 'normal';
    }

    // Validate sound enabled setting from localStorage
    function validateSoundEnabled(value) {
      return value === 'true';
    }

    // Get UI text for the current language
    function getUIText(key) {
      if (uiTextJson[key] && uiTextJson[key][currentLanguage]) {
        return uiTextJson[key][currentLanguage];
      }
      // Fallback to English if key or language not found
      if (uiTextJson[key] && uiTextJson[key]['english']) {
        return uiTextJson[key]['english'];
      }
      return key; // Return key itself as last resort
    }

    // Get language descriptor for task instructions
    function getLanguageDescriptor() {
      const descriptorKey = `language_descriptor_${currentLanguage}`;
      return getUIText(descriptorKey);
    }

    // State
    let currentPuzzle = null;
    let correctAnswers = {};
    let activeColors = [];
    let hasChecked = false;
    let answerKeyRevealed = false;
    // Validate language from localStorage
    let currentLanguage = validateLanguage(localStorage.getItem('colorFocusLanguage') || 'zh-TW');
    // Validate grid size from localStorage (default: 4)
    let currentGridSize = validateGridSize(localStorage.getItem('colorFocusGridSize') || 4);
    // Validate difficulty from localStorage (default: standard)
    let currentDifficulty = validateDifficulty(localStorage.getItem('colorFocusDifficulty') || 'standard');
    // Validate spacing from localStorage (default: normal)
    let currentSpacing = validateSpacing(localStorage.getItem('colorFocusSpacing') || 'normal');
    // Tile selection state for counting tiles feature
    let selectedTiles = new Set();
    // Sound enabled state for tile selection (default: off for accessibility)
    let soundEnabled = validateSoundEnabled(localStorage.getItem('colorFocusSoundEnabled'));
    // Track currently focused tile index for keyboard navigation (roving tabindex)
    let focusedTileIndex = 0;
    // Audio context for selection sound (lazy initialized)
    let audioContext = null;

    // ===========================================
    // AUTH STATE AND FUNCTIONS
    // ===========================================
    let currentUser = null;

    // Sign in with Google OAuth
    async function signInWithGoogle() {
      if (!supabase) {
        console.warn('Supabase not configured. Please set SUPABASE_URL and SUPABASE_ANON_KEY.');
        alert('Authentication not configured. Please contact the administrator.');
        return;
      }
      try {
        const { data, error } = await supabase.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: window.location.origin + window.location.pathname
          }
        });
        if (error) {
          console.error('Sign in error:', error.message);
          alert(getUIText('auth_error_signin') || 'Sign in failed. Please try again.');
        }
      } catch (err) {
        console.error('Sign in failed:', err);
        alert(getUIText('auth_error_signin') || 'Sign in failed. Please try again.');
      }
    }

    // Sign out
    async function signOut() {
      if (!supabase) return;
      try {
        const { error } = await supabase.auth.signOut();
        if (error) {
          console.error('Sign out error:', error.message);
          alert(getUIText('auth_error_signout') || 'Sign out failed. Please try again.');
        }
      } catch (err) {
        console.error('Sign out failed:', err);
        alert(getUIText('auth_error_signout') || 'Sign out failed. Please try again.');
      }
    }

    // Update UI based on auth state
    function updateAuthUI(user) {
      const loginBtn = document.getElementById('loginBtn');
      const userInfo = document.getElementById('userInfo');
      const userName = document.getElementById('userName');
      const userAvatar = document.getElementById('userAvatar');

      if (user) {
        loginBtn.style.display = 'none';
        userInfo.style.display = 'flex';

        // Use display name or email
        const displayName = user.user_metadata?.full_name ||
                            user.user_metadata?.name ||
                            user.email?.split('@')[0] ||
                            'User';
        userName.textContent = displayName;

        // Use avatar URL or keep placeholder
        const avatarUrl = user.user_metadata?.avatar_url ||
                          user.user_metadata?.picture;
        if (avatarUrl) {
          userAvatar.src = avatarUrl;
        }
        userAvatar.alt = `${displayName}'s avatar`;
      } else {
        loginBtn.style.display = 'flex';
        userInfo.style.display = 'none';
      }
    }

    // Initialize auth state listener
    function initAuthListener() {
      if (!supabase) {
        // Hide auth section if not configured
        document.getElementById('authSection').style.display = 'none';
        return;
      }

      supabase.auth.onAuthStateChange((event, session) => {
        console.log('Auth event:', event);
        if (session?.user) {
          currentUser = session.user;
          updateAuthUI(session.user);
        } else {
          currentUser = null;
          updateAuthUI(null);
        }
      });
    }

    // Check for existing session on page load
    async function checkExistingSession() {
      if (!supabase) return;
      try {
        const { data: { session }, error } = await supabase.auth.getSession();
        if (error) {
          console.error('Session check error:', error.message);
          return;
        }
        if (session?.user) {
          currentUser = session.user;
          updateAuthUI(session.user);
        }
      } catch (err) {
        console.error('Failed to check session:', err);
      }
    }

    // ===========================================
    // PUZZLE HISTORY STORAGE
    // ===========================================

    // Save completed puzzle to history
    async function savePuzzleHistory(userAnswers, accuracy) {
      if (!supabase || !currentUser) {
        console.log('Not saving history: user not authenticated');
        return null;
      }

      // Map frontend language values to database enum
      const languageMap = {
        'zh-TW': 'zh-TW',
        'english': 'en',
        'spanish': 'es',
        'vietnamese': 'vi'
      };

      const puzzleData = {
        user_id: currentUser.id,
        seed: document.getElementById('seed').value,
        grid_size: currentGridSize,
        color_count: parseInt(document.getElementById('colorCount').value),
        congruence_percent: parseInt(document.getElementById('matchPercent').value),
        difficulty: currentDifficulty,
        language: languageMap[currentLanguage] || 'en',
        user_answers: userAnswers,
        correct_answers: correctAnswers,
        accuracy_percent: accuracy
      };

      try {
        const { data, error } = await supabase
          .from('puzzle_history')
          .insert(puzzleData)
          .select()
          .single();

        if (error) {
          console.error('Error saving puzzle history:', error.message);
          return null;
        }

        console.log('Puzzle saved to history:', data.id);
        return data;
      } catch (err) {
        console.error('Failed to save puzzle history:', err);
        return null;
      }
    }

    // Fetch user's puzzle history
    async function getPuzzleHistory(limit = 10) {
      if (!supabase || !currentUser) return [];

      try {
        const { data, error } = await supabase
          .from('puzzle_history')
          .select('*')
          .eq('user_id', currentUser.id)
          .order('completed_at', { ascending: false })
          .limit(limit);

        if (error) {
          console.error('Error fetching history:', error.message);
          return [];
        }

        return data;
      } catch (err) {
        console.error('Failed to fetch history:', err);
        return [];
      }
    }

    // Initialize language selector with saved preference
    document.getElementById('language').value = currentLanguage;

    // Initialize grid size selector with saved preference
    document.getElementById('gridSize').value = currentGridSize;

    // Initialize difficulty selector with saved preference
    document.getElementById('difficulty').value = currentDifficulty;

    // Initialize spacing selector with saved preference
    document.getElementById('spacing').value = currentSpacing;

    // Initialize sound toggle with saved preference
    document.getElementById('soundToggle').checked = soundEnabled;

    // Show/hide custom controls based on difficulty
    function updateCustomControlsVisibility() {
      const isCustom = currentDifficulty === 'custom';
      document.querySelectorAll('.custom-control').forEach(el => {
        el.classList.toggle('visible', isCustom);
      });
    }

    // Apply difficulty preset to controls
    function applyDifficultyPreset(difficulty) {
      if (difficulty === 'custom') return; // Don't modify values in custom mode

      const preset = DIFFICULTY_PRESETS[difficulty];
      if (!preset) return;

      // Update state
      currentGridSize = preset.gridSize;

      // Update UI - grid size and congruence first
      document.getElementById('gridSize').value = preset.gridSize;
      document.getElementById('congruence').value = preset.congruencePercent;

      // Save grid size preference
      localStorage.setItem('colorFocusGridSize', currentGridSize);

      // Update color dropdown options for new grid size, then set color count
      updateColorDropdownOptions();
      document.getElementById('colorCount').value = preset.colorCount;
    }

    // Update grid CSS for current grid size and spacing
    function updateGridCSS() {
      const grid = document.getElementById('puzzleGrid');
      grid.style.gridTemplateColumns = `repeat(${currentGridSize}, 1fr)`;
      grid.style.gap = `${SPACING_VALUES[currentSpacing]}px`;
    }

    // Update Colors dropdown based on grid size (auto-limiting)
    function updateColorDropdownOptions() {
      const colorSelect = document.getElementById('colorCount');
      const maxColors = Math.min(8, currentGridSize);
      const currentColorValue = parseInt(colorSelect.value, 10);

      // Clear existing options
      colorSelect.innerHTML = '';

      // Add options from 1 to maxColors (minimum 1 color for 1x1 grid)
      const minColors = Math.min(2, maxColors);
      for (let i = minColors; i <= maxColors; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = i;
        if (i === Math.min(currentColorValue, maxColors)) {
          option.selected = true;
        }
        colorSelect.appendChild(option);
      }

      // If current selection exceeds new max, clamp it
      if (currentColorValue > maxColors) {
        colorSelect.value = maxColors;
      }
    }

    // Update all UI text elements with translations
    function updateAllUIText() {
      // Update page title (h1 and document.title)
      const pageTitle = getUIText('page_title');
      document.getElementById('pageTitle').textContent = pageTitle;
      document.title = pageTitle;

      // Update subtitle
      document.getElementById('subtitle').textContent = getUIText('subtitle');

      // Update donation link text
      document.getElementById('donationLink').textContent = getUIText('support_link_text');

      // Update donation QR code label
      document.getElementById('donationLabel').textContent = getUIText('qr_code_label');

      // Update button text
      document.getElementById('generateBtn').textContent = getUIText('generate_btn');
      document.getElementById('randomBtn').textContent = getUIText('random_btn');
      document.getElementById('settingsBtnText').textContent = getUIText('settings_btn');
      document.getElementById('checkBtn').textContent = getUIText('check_btn');
      document.getElementById('clearBtn').textContent = getUIText('clear_btn');

      // Update reveal button based on current state
      const revealBtn = document.getElementById('revealBtn');
      revealBtn.textContent = answerKeyRevealed ? getUIText('hide_btn') : getUIText('reveal_btn');

      // Update section headers
      document.getElementById('enterAnswersHeader').textContent = getUIText('enter_answers_header');
      document.getElementById('resultsHeader').textContent = getUIText('results_header');
      document.getElementById('answerKeyHeader').textContent = getUIText('answer_key_header');

      // Update reveal warning
      document.getElementById('revealWarning').textContent = getUIText('reveal_warning');

      // Update clear selections button text
      document.getElementById('clearSelectionsBtn').textContent = getUIText('clear_selections_btn');

      // Update Settings Modal
      document.getElementById('settingsModalTitle').textContent = getUIText('settings_title');
      document.getElementById('settingsDisplayTitle').textContent = getUIText('settings_display_section');
      document.getElementById('settingsPuzzleTitle').textContent = getUIText('settings_puzzle_section');
      document.getElementById('modalLanguageLabel').textContent = getUIText('settings_language');
      document.getElementById('modalSpacingLabel').textContent = getUIText('settings_spacing');
      document.getElementById('modalSoundLabel').textContent = getUIText('settings_sound');
      document.getElementById('modalDifficultyLabel').textContent = getUIText('settings_difficulty');
      document.getElementById('modalGridLabel').textContent = getUIText('settings_grid_size');
      document.getElementById('modalColorsLabel').textContent = getUIText('settings_colors');
      document.getElementById('modalMatchLabel').textContent = getUIText('settings_match');
      document.getElementById('modalSeedLabel').textContent = getUIText('settings_seed');

      // Update difficulty dropdown options in modal
      const modalDifficultySelect = document.getElementById('modalDifficulty');
      modalDifficultySelect.options[0].textContent = getUIText('difficulty_accessible');
      modalDifficultySelect.options[1].textContent = getUIText('difficulty_standard');
      modalDifficultySelect.options[2].textContent = getUIText('difficulty_advanced');
      modalDifficultySelect.options[3].textContent = getUIText('difficulty_custom');

      // Update spacing dropdown options in modal
      const modalSpacingSelect = document.getElementById('modalSpacing');
      modalSpacingSelect.options[0].textContent = getUIText('spacing_compact');
      modalSpacingSelect.options[1].textContent = getUIText('spacing_normal');
      modalSpacingSelect.options[2].textContent = getUIText('spacing_relaxed');
      modalSpacingSelect.options[3].textContent = getUIText('spacing_spacious');

      // Update About Modal
      document.getElementById('aboutModalTitle').textContent = getUIText('about_title');
      document.getElementById('aboutTagline').textContent = getUIText('about_tagline');
      document.getElementById('aboutHowToPlayTitle').textContent = getUIText('about_how_to_play_title');
      document.getElementById('aboutHowToPlayText').textContent = getUIText('about_how_to_play_text');
      document.getElementById('aboutWhatTitle').textContent = getUIText('about_what_title');
      document.getElementById('aboutWhatText').textContent = getUIText('about_what_text');
      document.getElementById('aboutStoryTitle').textContent = getUIText('about_story_title');
      // For story text, use innerHTML to preserve line breaks
      const storyText = getUIText('about_story_text').replace(/\n\n/g, '</p><p>').replace(/\n/g, ' ');
      document.getElementById('aboutStoryText').innerHTML = '<p>' + storyText + '</p>';
      document.getElementById('aboutSupportLink').textContent = getUIText('about_support_link');
    }

    // Add difficulty change event listener
    document.getElementById('difficulty').addEventListener('change', (e) => {
      currentDifficulty = validateDifficulty(e.target.value);
      localStorage.setItem('colorFocusDifficulty', currentDifficulty);
      updateCustomControlsVisibility();
      applyDifficultyPreset(currentDifficulty);
      generatePuzzle();
    });

    // Add language change event listener
    document.getElementById('language').addEventListener('change', (e) => {
      currentLanguage = e.target.value;
      localStorage.setItem('colorFocusLanguage', currentLanguage);
      updateAllUIText();
      renderPuzzleDisplay();
      renderAnswerInputs();
      renderAnswerKey();
      updateMetadata();
      // Recalculate font size for new language (different word lengths)
      applyPuzzleFontSize();
    });

    // Add spacing change event listener
    document.getElementById('spacing').addEventListener('change', (e) => {
      currentSpacing = validateSpacing(e.target.value);
      localStorage.setItem('colorFocusSpacing', currentSpacing);
      updateGridCSS();
      // Recalculate font size since spacing affects cell width
      applyPuzzleFontSize();
    });

    // Add grid size change event listener (only active in Custom mode)
    document.getElementById('gridSize').addEventListener('change', (e) => {
      currentGridSize = validateGridSize(e.target.value);
      localStorage.setItem('colorFocusGridSize', currentGridSize);
      updateGridCSS();
      updateColorDropdownOptions();
      generatePuzzle();
    });

    // Add sound toggle event listener
    document.getElementById('soundToggle').addEventListener('change', (e) => {
      soundEnabled = e.target.checked;
      localStorage.setItem('colorFocusSoundEnabled', String(soundEnabled));
    });

    // Seeded random number generator (mulberry32)
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    // Shuffle array with seeded random
    function shuffle(array, random) {
      const result = [...array];
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    }

    // Calculate optimal font size based on viewport, language, and grid size
    // Uses dynamic calculation: baseFontSize = (cellWidth * 0.8) / languageWidthMultiplier
    // The 0.8 factor achieves 80% text width with 10% margins on each side
    function calculatePuzzleFontSize() {
      const viewportWidth = window.innerWidth;
      const isMobile = viewportWidth <= 480;

      // Get actual grid width from DOM
      const grid = document.getElementById('puzzleGrid');
      const gridWidth = grid ? grid.offsetWidth : (isMobile ? viewportWidth - 40 : 800);

      // Use currentGridSize for column count
      const columns = currentGridSize;

      // Get current gap value from SPACING_VALUES based on current spacing setting
      // Mobile media query forces 1px gap, otherwise use the spacing setting
      const gapValue = isMobile ? 1 : SPACING_VALUES[currentSpacing];

      // Calculate total gap width: (columns - 1) gaps between columns
      const totalGapWidth = (columns - 1) * gapValue;

      // Mobile has extra cell padding (0.1rem = ~1.6px per cell)
      const cellPadding = isMobile ? columns * 3.2 : 0;

      // Calculate cell width: (gridWidth - totalGapWidth - cellPadding) / columns
      const cellWidth = (gridWidth - totalGapWidth - cellPadding) / columns;

      // Font size multipliers based on language (character width relative to font size)
      // These represent the approximate em-width of the longest word in each language
      // zh-TW: single character ~1.15em wide (e.g., "黑", "黃")
      // Vietnamese: "Vang" = 4 chars ~2.4em wide
      // English: "Yellow" = 6 chars ~3.6em wide
      // Spanish: "Amarillo" = 8 chars ~4.8em wide
      const widthMultipliers = {
        'zh-TW': 1.15,
        vietnamese: 2.4,
        english: 3.6,
        spanish: 4.8
      };

      const multiplier = widthMultipliers[currentLanguage] || 2.5;

      // Dynamic font calculation: (cellWidth * 0.8) / multiplier
      // The 0.8 factor achieves ~80% text width, leaving ~10% margin on each side
      let fontSize = (cellWidth * 0.8) / multiplier;

      // Apply a practical minimum floor (4px is below readable threshold)
      // Font cannot be larger than cell dimensions for fitting
      const minFontSize = 4;
      const maxFontSize = cellWidth * 0.9; // Font shouldn't exceed 90% of cell width

      fontSize = Math.max(minFontSize, Math.min(maxFontSize, fontSize));

      return fontSize;
    }

    // Apply calculated font size to puzzle cells
    function applyPuzzleFontSize() {
      const fontSize = calculatePuzzleFontSize();
      const cells = document.querySelectorAll('.puzzle-cell');
      // Always apply calculated font size for responsive language support
      cells.forEach(cell => cell.style.fontSize = `${fontSize}px`);
    }

    // Play selection sound using Web Audio API
    function playSelectionSound() {
      if (!soundEnabled) return;

      try {
        // Lazy initialize AudioContext (must be triggered by user interaction)
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Resume AudioContext if suspended (browsers require user interaction)
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        // Create a short, pleasant "pop" sound
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        // Use a pleasant frequency (C5 note = 523.25 Hz)
        oscillator.frequency.value = 523.25;
        oscillator.type = 'sine';

        // Quick attack, short sustain, fast decay for a "pop" effect
        const now = audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.3, now + 0.02); // Quick attack
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1); // Fast decay

        oscillator.start(now);
        oscillator.stop(now + 0.1);
      } catch (e) {
        // Silently fail if audio is not supported
        console.warn('Audio playback failed:', e);
      }
    }

    // Toggle tile selection state
    function toggleTileSelection(index) {
      const cell = document.querySelector(`.puzzle-cell[data-index="${index}"]`);
      if (!cell) return;

      if (selectedTiles.has(index)) {
        selectedTiles.delete(index);
        cell.classList.remove('selected');
        cell.setAttribute('aria-pressed', 'false');
      } else {
        selectedTiles.add(index);
        cell.classList.add('selected');
        cell.setAttribute('aria-pressed', 'true');
        // Play sound only on selection, not deselection
        playSelectionSound();
      }
    }

    // Clear all tile selections
    function clearAllSelections() {
      selectedTiles.clear();
      document.querySelectorAll('.puzzle-cell.selected').forEach(cell => {
        cell.classList.remove('selected');
        cell.setAttribute('aria-pressed', 'false');
      });
    }

    // Calculate new tile index based on arrow key direction
    function calculateNewTileIndex(currentIndex, key, gridSize) {
      const row = Math.floor(currentIndex / gridSize);
      const col = currentIndex % gridSize;

      switch (key) {
        case 'ArrowUp':
          return row > 0 ? currentIndex - gridSize : currentIndex;
        case 'ArrowDown':
          return row < gridSize - 1 ? currentIndex + gridSize : currentIndex;
        case 'ArrowLeft':
          return col > 0 ? currentIndex - 1 : currentIndex;
        case 'ArrowRight':
          return col < gridSize - 1 ? currentIndex + 1 : currentIndex;
        default:
          return currentIndex;
      }
    }

    // Handle keyboard navigation within the puzzle grid
    function handleGridKeydown(event) {
      const key = event.key;

      // Handle arrow key navigation
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
        event.preventDefault();
        const newIndex = calculateNewTileIndex(focusedTileIndex, key, currentGridSize);

        if (newIndex !== focusedTileIndex) {
          // Update roving tabindex
          const currentCell = document.querySelector(`.puzzle-cell[data-index="${focusedTileIndex}"]`);
          const newCell = document.querySelector(`.puzzle-cell[data-index="${newIndex}"]`);

          if (currentCell && newCell) {
            currentCell.setAttribute('tabindex', '-1');
            newCell.setAttribute('tabindex', '0');
            newCell.focus();
            focusedTileIndex = newIndex;
          }
        }
      }

      // Handle spacebar to toggle selection
      if (key === ' ' || key === 'Spacebar') {
        event.preventDefault();
        toggleTileSelection(focusedTileIndex);
      }
    }

    // Handle auto-fill when color swatch is clicked
    function handleSwatchClick(token) {
      const input = document.getElementById(`answer-${token}`);
      if (input) {
        input.value = String(selectedTiles.size);
      }
    }

    // Render the puzzle grid display (without regenerating data)
    function renderPuzzleDisplay() {
      if (!currentPuzzle) return;

      const grid = document.getElementById('puzzleGrid');
      grid.innerHTML = '';

      // Reset focused tile index when re-rendering
      focusedTileIndex = 0;

      currentPuzzle.forEach((cell, index) => {
        const div = document.createElement('div');
        div.className = 'puzzle-cell';
        div.setAttribute('data-index', index);
        div.setAttribute('role', 'gridcell');
        div.textContent = colorLabelsJson[cell.word][currentLanguage];
        div.style.color = colorsJson[cell.inkColor];

        // Apply selected class and aria-pressed if tile is in selectedTiles set
        if (selectedTiles.has(index)) {
          div.classList.add('selected');
          div.setAttribute('aria-pressed', 'true');
        } else {
          div.setAttribute('aria-pressed', 'false');
        }

        // Roving tabindex: first tile gets tabindex 0, others get -1
        div.setAttribute('tabindex', index === 0 ? '0' : '-1');

        // Add click handler for tile selection
        div.addEventListener('click', () => {
          toggleTileSelection(index);
          // Update focus to clicked tile
          const previousCell = document.querySelector(`.puzzle-cell[data-index="${focusedTileIndex}"]`);
          if (previousCell) {
            previousCell.setAttribute('tabindex', '-1');
          }
          div.setAttribute('tabindex', '0');
          focusedTileIndex = index;
        });

        // Add keyboard event handler
        div.addEventListener('keydown', handleGridKeydown);

        grid.appendChild(div);
      });

      // Apply font size after rendering
      applyPuzzleFontSize();
    }

    // Recalculate font size on window resize
    window.addEventListener('resize', () => {
      if (currentPuzzle) {
        applyPuzzleFontSize();
      }
    });

    // Recalculate font size on orientation change (mobile devices)
    window.addEventListener('orientationchange', () => {
      if (currentPuzzle) {
        // Small delay to allow viewport to update after orientation change
        setTimeout(() => {
          applyPuzzleFontSize();
        }, 100);
      }
    });

    // Store current puzzle metadata for re-rendering
    let currentSeed = 42;
    let currentColorCount = 4;
    let currentCongruentCount = 0;

    // Update metadata display with translated labels
    function updateMetadata() {
      if (!currentPuzzle) return;

      const metaDiv = document.getElementById('metadata');
      metaDiv.textContent = ''; // Clear safely

      // Use dynamic totalCells based on currentGridSize
      const totalCells = currentGridSize * currentGridSize;
      const gridSizeDisplay = `${currentGridSize}x${currentGridSize}`;
      const metaItems = [
        { label: getUIText('metadata_seed'), value: String(currentSeed) },
        { label: getUIText('metadata_colors'), value: String(currentColorCount) },
        { label: getUIText('metadata_grid'), value: gridSizeDisplay },
        { label: getUIText('metadata_congruent'), value: `${currentCongruentCount}/${totalCells} (${(currentCongruentCount/totalCells*100).toFixed(1)}%)` }
      ];

      metaItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'metadata-item';

        const labelSpan = document.createElement('span');
        labelSpan.textContent = item.label;
        div.appendChild(labelSpan);

        const valueSpan = document.createElement('span');
        valueSpan.className = 'metadata-value';
        valueSpan.textContent = item.value;
        div.appendChild(valueSpan);

        metaDiv.appendChild(div);
      });
    }

    // Generate puzzle
    function generatePuzzle() {
      // Reset state
      hasChecked = false;
      answerKeyRevealed = false;
      selectedTiles.clear();
      focusedTileIndex = 0;
      document.getElementById('answerKeyContent').classList.remove('revealed');
      document.getElementById('revealBtn').textContent = getUIText('reveal_btn');
      document.getElementById('revealWarning').style.display = 'block';
      document.getElementById('resultsSection').classList.remove('visible');
      document.getElementById('checkBtn').disabled = false;

      const seedInput = document.getElementById('seed');
      const congruenceInput = document.getElementById('congruence');
      const colorCountSelect = document.getElementById('colorCount');

      // Apply input sanitization for security
      const seed = sanitizeNumber(seedInput.value, 0, 2147483647, 42);
      const congruencePercent = sanitizeNumber(congruenceInput.value, 0, 100, 12.5);
      const congruence = congruencePercent / 100;
      const colorCount = sanitizeNumber(colorCountSelect.value, 1, 8, 4);

      // Store for metadata re-rendering
      currentSeed = seed;
      currentColorCount = colorCount;

      const random = mulberry32(seed);
      activeColors = COLOR_SUBSETS[colorCount] || COLOR_SUBSETS[2];

      // Create ink distribution (roughly equal with small variations)
      // Use dynamic totalCells based on currentGridSize
      const totalCells = currentGridSize * currentGridSize;
      const basePerColor = Math.floor(totalCells / colorCount);

      // Create base distribution then add random variation
      let inkColors = [];
      let remaining = totalCells;

      activeColors.forEach((token, i) => {
        if (i === activeColors.length - 1) {
          // Last color gets whatever remains
          for (let j = 0; j < remaining; j++) {
            inkColors.push(token);
          }
        } else {
          // Add variation: +/-2 from base, but keep within bounds
          const variation = Math.floor(random() * 5) - 2; // -2 to +2
          const count = Math.max(1, Math.min(basePerColor + 2, basePerColor + variation));
          for (let j = 0; j < count; j++) {
            inkColors.push(token);
          }
          remaining -= count;
        }
      });
      inkColors = shuffle(inkColors, random);

      // Assign words with congruence control
      const cells = inkColors.map(inkColor => {
        let word;
        if (random() < congruence) {
          word = inkColor; // Congruent
        } else {
          // Pick different color from active colors
          const otherColors = activeColors.filter(c => c !== inkColor);
          word = otherColors.length > 0
            ? otherColors[Math.floor(random() * otherColors.length)]
            : inkColor;
        }
        return { word, inkColor };
      });

      currentPuzzle = cells;

      // Update grid CSS for current grid size
      updateGridCSS();

      // Render grid
      renderPuzzleDisplay();

      // Count distribution (correct answers)
      correctAnswers = {};
      let congruentCount = 0;
      cells.forEach(cell => {
        correctAnswers[cell.inkColor] = (correctAnswers[cell.inkColor] || 0) + 1;
        if (cell.word === cell.inkColor) congruentCount++;
      });
      currentCongruentCount = congruentCount;

      // Render answer input grid
      renderAnswerInputs();

      // Render answer key (hidden)
      renderAnswerKey();

      // Render metadata with translated labels
      updateMetadata();
    }

    // Render answer input fields (only active colors)
    function renderAnswerInputs() {
      const answerGrid = document.getElementById('answerGrid');
      answerGrid.textContent = ''; // Clear safely

      // Calculate max input value based on current grid size
      const maxInputValue = currentGridSize * currentGridSize;

      // Only show active colors for this puzzle
      activeColors.forEach(token => {
        const item = document.createElement('div');
        item.className = 'answer-item';
        item.id = `answer-item-${token}`;

        // Create swatch with auto-fill click handler
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = colorsJson[token];
        swatch.setAttribute('role', 'button');
        swatch.setAttribute('tabindex', '0');
        swatch.setAttribute('aria-label', 'Auto-fill with selected tile count');
        swatch.addEventListener('click', () => handleSwatchClick(token));
        swatch.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            handleSwatchClick(token);
          }
        });
        item.appendChild(swatch);

        // Create label
        const label = document.createElement('span');
        label.className = 'answer-label';
        label.textContent = colorLabelsJson[token][currentLanguage];
        item.appendChild(label);

        // Create input
        const input = document.createElement('input');
        input.type = 'number';
        input.className = 'answer-input';
        input.id = `answer-${token}`;
        input.min = '0';
        input.max = String(maxInputValue);
        input.placeholder = '?';
        item.appendChild(input);

        // Create correct value span
        const correctSpan = document.createElement('span');
        correctSpan.className = 'correct-value';
        correctSpan.id = `correct-${token}`;
        item.appendChild(correctSpan);

        answerGrid.appendChild(item);
      });

      // Add enter key handler to check answers
      answerGrid.querySelectorAll('input').forEach(input => {
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            checkAnswers();
          }
        });
      });
    }

    // Render answer key (only active colors, hidden by default)
    function renderAnswerKey() {
      const keyGrid = document.getElementById('answerKeyGrid');
      keyGrid.textContent = ''; // Clear safely

      // Only show active colors for this puzzle
      activeColors.forEach(token => {
        const item = document.createElement('div');
        item.className = 'answer-key-item';

        // Create swatch
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = colorsJson[token];
        item.appendChild(swatch);

        // Create label
        const label = document.createElement('span');
        label.className = 'answer-key-label';
        label.textContent = colorLabelsJson[token][currentLanguage];
        item.appendChild(label);

        // Create count
        const count = document.createElement('span');
        count.className = 'answer-key-count';
        count.textContent = String(correctAnswers[token]);
        item.appendChild(count);

        keyGrid.appendChild(item);
      });
    }

    // Check answers
    function checkAnswers() {
      if (!currentPuzzle) return;

      hasChecked = true;
      let correctCount = 0;
      let totalOff = 0;

      // Calculate max value based on current grid size
      const maxValue = currentGridSize * currentGridSize;

      // Collect user answers for history
      const userAnswersObj = {};

      activeColors.forEach(token => {
        const input = document.getElementById(`answer-${token}`);
        const item = document.getElementById(`answer-item-${token}`);
        const correctSpan = document.getElementById(`correct-${token}`);
        // Sanitize user input
        const userAnswer = sanitizeNumber(input.value, 0, maxValue, 0);
        const correct = correctAnswers[token];

        // Store user answer
        userAnswersObj[token] = userAnswer;

        input.classList.remove('correct', 'incorrect');
        item.classList.remove('correct', 'incorrect');

        if (userAnswer === correct) {
          input.classList.add('correct');
          item.classList.add('correct');
          correctSpan.textContent = '';
          correctCount++;
        } else {
          input.classList.add('incorrect');
          item.classList.add('incorrect');
          correctSpan.textContent = correct;
          totalOff += Math.abs(userAnswer - correct);
        }
      });

      // Show results
      showResults(correctCount, activeColors.length, totalOff);

      // Save to history if user is authenticated
      if (currentUser) {
        const accuracy = Math.round((correctCount / activeColors.length) * 100);
        savePuzzleHistory(userAnswersObj, accuracy);
      }
    }

    // Show results with translated messages
    function showResults(correct, total, totalOff) {
      const resultsSection = document.getElementById('resultsSection');
      const resultsSummary = document.getElementById('resultsSummary');
      const resultMessage = document.getElementById('resultMessage');

      const percentage = Math.round((correct / total) * 100);
      let scoreClass, message;

      if (correct === total) {
        scoreClass = 'perfect';
        message = getUIText('result_perfect');
      } else if (percentage >= 75) {
        scoreClass = 'good';
        message = getUIText('result_good')
          .replace('{correct}', String(correct))
          .replace('{total}', String(total));
      } else {
        scoreClass = 'needs-work';
        message = getUIText('result_needs_work')
          .replace('{correct}', String(correct))
          .replace('{total}', String(total));
      }

      // Build results using safe DOM manipulation
      resultsSummary.textContent = ''; // Clear safely

      const stats = [
        { value: `${correct}/${total}`, label: getUIText('result_colors_correct'), hasClass: true },
        { value: `${percentage}%`, label: getUIText('result_accuracy'), hasClass: true },
        { value: String(totalOff), label: getUIText('result_total_off'), hasClass: false }
      ];

      stats.forEach(stat => {
        const div = document.createElement('div');
        div.className = stat.hasClass ? `result-stat ${scoreClass}` : 'result-stat';

        const valueDiv = document.createElement('div');
        valueDiv.className = 'value';
        valueDiv.textContent = stat.value;
        div.appendChild(valueDiv);

        const labelDiv = document.createElement('div');
        labelDiv.className = 'label';
        labelDiv.textContent = stat.label;
        div.appendChild(labelDiv);

        resultsSummary.appendChild(div);
      });

      resultMessage.className = `result-message ${scoreClass}`;
      resultMessage.textContent = message;

      resultsSection.classList.add('visible');
    }

    // Clear answers
    function clearAnswers() {
      ALL_COLOR_TOKENS.forEach(token => {
        const input = document.getElementById(`answer-${token}`);
        const item = document.getElementById(`answer-item-${token}`);
        const correctSpan = document.getElementById(`correct-${token}`);

        if (input) {
          input.value = '';
          input.classList.remove('correct', 'incorrect');
        }
        if (item) {
          item.classList.remove('correct', 'incorrect');
        }
        if (correctSpan) {
          correctSpan.textContent = '';
        }
      });

      document.getElementById('resultsSection').classList.remove('visible');
      hasChecked = false;
    }

    // Toggle answer key visibility
    function toggleAnswerKey() {
      const content = document.getElementById('answerKeyContent');
      const btn = document.getElementById('revealBtn');
      const warning = document.getElementById('revealWarning');

      if (answerKeyRevealed) {
        content.classList.remove('revealed');
        btn.textContent = getUIText('reveal_btn');
        answerKeyRevealed = false;
        warning.style.display = 'block';
      } else {
        content.classList.add('revealed');
        btn.textContent = getUIText('hide_btn');
        answerKeyRevealed = true;
        warning.style.display = 'none';
      }
    }

    function randomSeed() {
      document.getElementById('seed').value = Math.floor(Math.random() * 1000000);
      document.getElementById('modalSeed').value = document.getElementById('seed').value;
      generatePuzzle();
    }

    // ===========================================
    // MODAL SYSTEM
    // ===========================================
    let currentModal = null;
    let previouslyFocusedElement = null;

    // Open a modal by ID
    function openModal(modalId) {
      const modal = document.getElementById(modalId);
      const backdrop = document.getElementById('modalBackdrop');
      if (!modal || !backdrop) return;

      // Store previously focused element for restoration
      previouslyFocusedElement = document.activeElement;

      // Sync modal controls with current state before opening
      if (modalId === 'settingsModal') {
        syncModalControlsFromState();
      }

      // Show modal and backdrop
      backdrop.classList.add('visible');
      modal.classList.add('visible');
      currentModal = modal;

      // Focus first focusable element in modal
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      if (focusableElements.length > 0) {
        focusableElements[0].focus();
      }

      // Add escape key listener
      document.addEventListener('keydown', handleModalEscape);

      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    }

    // Close current modal
    function closeModal() {
      if (!currentModal) return;

      const backdrop = document.getElementById('modalBackdrop');

      // If settings modal, apply changes
      if (currentModal.id === 'settingsModal') {
        applyModalSettings();
      }

      // Hide modal and backdrop
      backdrop.classList.remove('visible');
      currentModal.classList.remove('visible');

      // Restore focus
      if (previouslyFocusedElement) {
        previouslyFocusedElement.focus();
      }

      // Remove escape key listener
      document.removeEventListener('keydown', handleModalEscape);

      // Restore body scroll
      document.body.style.overflow = '';

      currentModal = null;
    }

    // Handle escape key
    function handleModalEscape(e) {
      if (e.key === 'Escape') {
        closeModal();
      }
    }

    // Handle backdrop click
    function handleBackdropClick(e) {
      if (e.target.id === 'modalBackdrop') {
        closeModal();
      }
    }

    // Sync modal controls to current app state
    function syncModalControlsFromState() {
      document.getElementById('modalLanguage').value = currentLanguage;
      document.getElementById('modalSpacing').value = currentSpacing;
      document.getElementById('modalSoundToggle').checked = soundEnabled;
      document.getElementById('modalDifficulty').value = currentDifficulty;
      document.getElementById('modalGridSize').value = currentGridSize;
      document.getElementById('modalColorCount').value = document.getElementById('colorCount').value;
      document.getElementById('modalCongruence').value = document.getElementById('congruence').value;
      document.getElementById('modalSeed').value = document.getElementById('seed').value;

      // Update custom controls visibility in modal
      updateModalCustomControlsVisibility();
    }

    // Apply modal settings to the app
    function applyModalSettings() {
      const newLanguage = document.getElementById('modalLanguage').value;
      const newSpacing = document.getElementById('modalSpacing').value;
      const newSound = document.getElementById('modalSoundToggle').checked;
      const newDifficulty = document.getElementById('modalDifficulty').value;
      const newGridSize = parseInt(document.getElementById('modalGridSize').value, 10);
      const newColorCount = document.getElementById('modalColorCount').value;
      const newCongruence = document.getElementById('modalCongruence').value;
      const newSeed = document.getElementById('modalSeed').value;

      let needsRegenerate = false;

      // Update language
      if (newLanguage !== currentLanguage) {
        currentLanguage = newLanguage;
        document.getElementById('language').value = newLanguage;
        localStorage.setItem('colorFocusLanguage', currentLanguage);
        updateAllUIText();
        renderPuzzleDisplay();
        renderAnswerInputs();
        renderAnswerKey();
        updateMetadata();
        applyPuzzleFontSize();
      }

      // Update spacing
      if (newSpacing !== currentSpacing) {
        currentSpacing = newSpacing;
        document.getElementById('spacing').value = newSpacing;
        localStorage.setItem('colorFocusSpacing', currentSpacing);
        updateGridCSS();
        applyPuzzleFontSize();
      }

      // Update sound
      if (newSound !== soundEnabled) {
        soundEnabled = newSound;
        document.getElementById('soundToggle').checked = newSound;
        localStorage.setItem('colorFocusSoundEnabled', String(soundEnabled));
      }

      // Update difficulty
      if (newDifficulty !== currentDifficulty) {
        currentDifficulty = newDifficulty;
        document.getElementById('difficulty').value = newDifficulty;
        localStorage.setItem('colorFocusDifficulty', currentDifficulty);
        updateCustomControlsVisibility();

        if (newDifficulty !== 'custom') {
          applyDifficultyPreset(currentDifficulty);
          needsRegenerate = true;
        }
      }

      // Update custom settings (only in custom mode)
      if (currentDifficulty === 'custom') {
        if (newGridSize !== currentGridSize) {
          currentGridSize = newGridSize;
          document.getElementById('gridSize').value = newGridSize;
          localStorage.setItem('colorFocusGridSize', currentGridSize);
          updateGridCSS();
          updateColorDropdownOptions();
          needsRegenerate = true;
        }

        document.getElementById('colorCount').value = newColorCount;
        document.getElementById('congruence').value = newCongruence;
        needsRegenerate = true;
      }

      // Update seed (always triggers regenerate if changed)
      if (newSeed !== document.getElementById('seed').value) {
        document.getElementById('seed').value = newSeed;
        needsRegenerate = true;
      }

      // Regenerate puzzle if settings changed
      if (needsRegenerate) {
        generatePuzzle();
      }
    }

    // Update custom controls visibility in modal
    function updateModalCustomControlsVisibility() {
      const isCustom = document.getElementById('modalDifficulty').value === 'custom';
      document.querySelectorAll('#settingsModal .custom-control').forEach(el => {
        el.classList.toggle('visible', isCustom);
      });
    }

    // Update modal color dropdown options based on grid size
    function updateModalColorDropdownOptions() {
      const colorSelect = document.getElementById('modalColorCount');
      const gridSize = parseInt(document.getElementById('modalGridSize').value, 10);
      const maxColors = Math.min(8, gridSize);
      const currentColorValue = parseInt(colorSelect.value, 10);

      // Clear existing options
      colorSelect.innerHTML = '';

      // Add options from 1 to maxColors
      const minColors = Math.min(2, maxColors);
      for (let i = minColors; i <= maxColors; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = i;
        if (i === Math.min(currentColorValue, maxColors)) {
          option.selected = true;
        }
        colorSelect.appendChild(option);
      }

      // If current selection exceeds new max, clamp it
      if (currentColorValue > maxColors) {
        colorSelect.value = maxColors;
      }
    }

    // Wire up event listeners (security: avoid global function exposure)
    document.getElementById('generateBtn').addEventListener('click', generatePuzzle);
    document.getElementById('randomBtn').addEventListener('click', randomSeed);
    document.getElementById('checkBtn').addEventListener('click', checkAnswers);
    document.getElementById('clearBtn').addEventListener('click', clearAnswers);
    document.getElementById('revealBtn').addEventListener('click', toggleAnswerKey);
    document.getElementById('clearSelectionsBtn').addEventListener('click', clearAllSelections);

    // Modal event listeners
    document.getElementById('settingsBtn').addEventListener('click', () => openModal('settingsModal'));
    document.getElementById('aboutBtn').addEventListener('click', () => openModal('aboutModal'));
    document.getElementById('settingsModalClose').addEventListener('click', closeModal);
    document.getElementById('aboutModalClose').addEventListener('click', closeModal);
    document.getElementById('modalBackdrop').addEventListener('click', handleBackdropClick);

    // Modal settings controls - update UI as user changes settings
    document.getElementById('modalDifficulty').addEventListener('change', updateModalCustomControlsVisibility);
    document.getElementById('modalGridSize').addEventListener('change', updateModalColorDropdownOptions);

    // Auth event listeners
    document.getElementById('loginBtn').addEventListener('click', signInWithGoogle);
    document.getElementById('logoutBtn').addEventListener('click', signOut);

    // Initialize custom controls visibility based on difficulty
    updateCustomControlsVisibility();

    // Apply difficulty preset if not custom (restores settings on page load)
    if (currentDifficulty !== 'custom') {
      applyDifficultyPreset(currentDifficulty);
    }

    // Initialize color dropdown options based on initial grid size
    updateColorDropdownOptions();

    // Initialize UI text with current language
    updateAllUIText();

    // Initialize auth
    initAuthListener();
    checkExistingSession();

    // Initial generation
    generatePuzzle();
  </script>
</body>
</html>
